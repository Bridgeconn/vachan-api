

(() => { var Sr = Object.create; var je = Object.defineProperty; var Nr = Object.getOwnPropertyDescriptor; var Dr = Object.getOwnPropertyNames; var Lr = Object.getPrototypeOf, Ir = Object.prototype.hasOwnProperty; var Si = t => je(t, "__esModule", { value: !0 }); var G = (t, e) => () => (t && (e = t(t = 0)), e); var Ht = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), xr = (t, e) => { for (var n in e) je(t, n, { get: e[n], enumerable: !0 }) }, Ni = (t, e, n, o) => { if (e && typeof e == "object" || typeof e == "function") for (let r of Dr(e)) !Ir.call(t, r) && (n || r !== "default") && je(t, r, { get: () => e[r], enumerable: !(o = Nr(e, r)) || o.enumerable }); return t }, Kt = (t, e) => Ni(Si(je(t != null ? Sr(Lr(t)) : {}, "default", !e && t && t.__esModule ? { get: () => t.default, enumerable: !0 } : { value: t, enumerable: !0 })), t), Di = (t => (e, n) => t && t.get(e) || (n = Ni(Si({}), e, 1), t && t.set(e, n), n))(typeof WeakMap != "undefined" ? new WeakMap : 0); var Ut = Ht((pn, hn) => { (function (t, e) { typeof pn == "object" && typeof hn != "undefined" ? hn.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis != "undefined" ? globalThis : t || self, t.EventHandler = e()) })(pn, function () { "use strict"; let t = () => { let { jQuery: _ } = window; return _ && !document.body.hasAttribute("data-bs-no-jquery") ? _ : null }, e = /[^.]*(?=\..*)\.|.*/, n = /\..*/, o = /::\d+$/, r = {}, i = 1, c = { mouseenter: "mouseover", mouseleave: "mouseout" }, s = /^(mouseenter|mouseleave)/i, E = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]); function S(_, l) { return l && `${l}::${i++}` || _.uidEvent || i++ } function v(_) { let l = S(_); return _.uidEvent = l, r[l] = r[l] || {}, r[l] } function J(_, l) { return function g(y) { return y.delegateTarget = _, g.oneOff && q.off(_, y.type, l), l.apply(_, [y]) } } function tt(_, l, g) { return function y(W) { let j = _.querySelectorAll(l); for (let { target: P } = W; P && P !== this; P = P.parentNode)for (let F = j.length; F--;)if (j[F] === P) return W.delegateTarget = P, y.oneOff && q.off(_, W.type, l, g), g.apply(P, [W]); return null } } function Y(_, l, g = null) { let y = Object.keys(_); for (let W = 0, j = y.length; W < j; W++) { let P = _[y[W]]; if (P.originalHandler === l && P.delegationSelector === g) return P } return null } function X(_, l, g) { let y = typeof l == "string", W = y ? g : l, j = D(_); return E.has(j) || (j = _), [y, W, j] } function T(_, l, g, y, W) { if (typeof l != "string" || !_) return; if (g || (g = y, y = null), s.test(l)) { let pt = Et => function (Z) { if (!Z.relatedTarget || Z.relatedTarget !== Z.delegateTarget && !Z.delegateTarget.contains(Z.relatedTarget)) return Et.call(this, Z) }; y ? y = pt(y) : g = pt(g) } let [j, P, F] = X(l, g, y), st = v(_), et = st[F] || (st[F] = {}), gt = Y(et, P, j ? g : null); if (gt) { gt.oneOff = gt.oneOff && W; return } let ct = S(P, l.replace(e, "")), nt = j ? tt(_, g, y) : J(_, g); nt.delegationSelector = j ? g : null, nt.originalHandler = P, nt.oneOff = W, nt.uidEvent = ct, et[ct] = nt, _.addEventListener(F, nt, j) } function O(_, l, g, y, W) { let j = Y(l[g], y, W); !j || (_.removeEventListener(g, j, Boolean(W)), delete l[g][j.uidEvent]) } function b(_, l, g, y) { let W = l[g] || {}; Object.keys(W).forEach(j => { if (j.includes(y)) { let P = W[j]; O(_, l, g, P.originalHandler, P.delegationSelector) } }) } function D(_) { return _ = _.replace(n, ""), c[_] || _ } let q = { on(_, l, g, y) { T(_, l, g, y, !1) }, one(_, l, g, y) { T(_, l, g, y, !0) }, off(_, l, g, y) { if (typeof l != "string" || !_) return; let [W, j, P] = X(l, g, y), F = P !== l, st = v(_), et = l.startsWith("."); if (typeof j != "undefined") { if (!st || !st[P]) return; O(_, st, P, j, W ? g : null); return } et && Object.keys(st).forEach(ct => { b(_, st, ct, l.slice(1)) }); let gt = st[P] || {}; Object.keys(gt).forEach(ct => { let nt = ct.replace(o, ""); if (!F || l.includes(nt)) { let pt = gt[ct]; O(_, st, P, pt.originalHandler, pt.delegationSelector) } }) }, trigger(_, l, g) { if (typeof l != "string" || !_) return null; let y = t(), W = D(l), j = l !== W, P = E.has(W), F, st = !0, et = !0, gt = !1, ct = null; return j && y && (F = y.Event(l, g), y(_).trigger(F), st = !F.isPropagationStopped(), et = !F.isImmediatePropagationStopped(), gt = F.isDefaultPrevented()), P ? (ct = document.createEvent("HTMLEvents"), ct.initEvent(W, st, !0)) : ct = new CustomEvent(l, { bubbles: st, cancelable: !0 }), typeof g != "undefined" && Object.keys(g).forEach(nt => { Object.defineProperty(ct, nt, { get() { return g[nt] } }) }), gt && ct.preventDefault(), et && _.dispatchEvent(ct), ct.defaultPrevented && typeof F != "undefined" && F.preventDefault(), ct } }; return q }) }); var Fe = Ht((mn, _n) => { (function (t, e) { typeof mn == "object" && typeof _n != "undefined" ? _n.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis != "undefined" ? globalThis : t || self, t.Data = e()) })(mn, function () { "use strict"; let t = new Map; return { set(n, o, r) { t.has(n) || t.set(n, new Map); let i = t.get(n); if (!i.has(o) && i.size !== 0) { console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(i.keys())[0]}.`); return } i.set(o, r) }, get(n, o) { return t.has(n) && t.get(n).get(o) || null }, remove(n, o) { if (!t.has(n)) return; let r = t.get(n); r.delete(o), r.size === 0 && t.delete(n) } } }) }); var Qt = Ht((gn, En) => { (function (t, e) { typeof gn == "object" && typeof En != "undefined" ? En.exports = e(Fe(), Ut()) : typeof define == "function" && define.amd ? define(["./dom/data", "./dom/event-handler"], e) : (t = typeof globalThis != "undefined" ? globalThis : t || self, t.Base = e(t.Data, t.EventHandler)) })(gn, function (t, e) { "use strict"; let n = T => T && typeof T == "object" && "default" in T ? T : { default: T }, o = n(t), r = n(e), i = 1e3, c = "transitionend", s = T => { if (!T) return 0; let { transitionDuration: O, transitionDelay: b } = window.getComputedStyle(T), D = Number.parseFloat(O), q = Number.parseFloat(b); return !D && !q ? 0 : (O = O.split(",")[0], b = b.split(",")[0], (Number.parseFloat(O) + Number.parseFloat(b)) * i) }, E = T => { T.dispatchEvent(new Event(c)) }, S = T => !T || typeof T != "object" ? !1 : (typeof T.jquery != "undefined" && (T = T[0]), typeof T.nodeType != "undefined"), v = T => S(T) ? T.jquery ? T[0] : T : typeof T == "string" && T.length > 0 ? document.querySelector(T) : null, J = T => { typeof T == "function" && T() }, tt = (T, O, b = !0) => { if (!b) { J(T); return } let D = 5, q = s(O) + D, _ = !1, l = ({ target: g }) => { g === O && (_ = !0, O.removeEventListener(c, l), J(T)) }; O.addEventListener(c, l), setTimeout(() => { _ || E(O) }, q) }, Y = "5.1.3"; class X { constructor(O) { O = v(O), !!O && (this._element = O, o.default.set(this._element, this.constructor.DATA_KEY, this)) } dispose() { o.default.remove(this._element, this.constructor.DATA_KEY), r.default.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach(O => { this[O] = null }) } _queueCallback(O, b, D = !0) { tt(O, b, D) } static getInstance(O) { return o.default.get(v(O), this.DATA_KEY) } static getOrCreateInstance(O, b = {}) { return this.getInstance(O) || new this(O, typeof b == "object" ? b : null) } static get VERSION() { return Y } static get NAME() { throw new Error('You have to implement the static method "NAME", for each component!') } static get DATA_KEY() { return `bs.${this.NAME}` } static get EVENT_KEY() { return `.${this.DATA_KEY}` } } return X }) }); var Li = Ht((vn, yn) => { (function (t, e) { typeof vn == "object" && typeof yn != "undefined" ? yn.exports = e(Ut(), Qt()) : typeof define == "function" && define.amd ? define(["./dom/event-handler", "./base-component"], e) : (t = typeof globalThis != "undefined" ? globalThis : t || self, t.Alert = e(t.EventHandler, t.Base)) })(vn, function (t, e) { "use strict"; let n = l => l && typeof l == "object" && "default" in l ? l : { default: l }, o = n(t), r = n(e), i = l => { let g = l.getAttribute("data-bs-target"); if (!g || g === "#") { let y = l.getAttribute("href"); if (!y || !y.includes("#") && !y.startsWith(".")) return null; y.includes("#") && !y.startsWith("#") && (y = `#${y.split("#")[1]}`), g = y && y !== "#" ? y.trim() : null } return g }, c = l => { let g = i(l); return g ? document.querySelector(g) : null }, s = l => !l || l.nodeType !== Node.ELEMENT_NODE || l.classList.contains("disabled") ? !0 : typeof l.disabled != "undefined" ? l.disabled : l.hasAttribute("disabled") && l.getAttribute("disabled") !== "false", E = () => { let { jQuery: l } = window; return l && !document.body.hasAttribute("data-bs-no-jquery") ? l : null }, S = [], v = l => { document.readyState === "loading" ? (S.length || document.addEventListener("DOMContentLoaded", () => { S.forEach(g => g()) }), S.push(l)) : l() }, J = l => { v(() => { let g = E(); if (g) { let y = l.NAME, W = g.fn[y]; g.fn[y] = l.jQueryInterface, g.fn[y].Constructor = l, g.fn[y].noConflict = () => (g.fn[y] = W, l.jQueryInterface) } }) }, tt = (l, g = "hide") => { let y = `click.dismiss${l.EVENT_KEY}`, W = l.NAME; o.default.on(document, y, `[data-bs-dismiss="${W}"]`, function (j) { if (["A", "AREA"].includes(this.tagName) && j.preventDefault(), s(this)) return; let P = c(this) || this.closest(`.${W}`); l.getOrCreateInstance(P)[g]() }) }, Y = "alert", T = ".bs.alert", O = `close${T}`, b = `closed${T}`, D = "fade", q = "show"; class _ extends r.default { static get NAME() { return Y } close() { if (o.default.trigger(this._element, O).defaultPrevented) return; this._element.classList.remove(q); let y = this._element.classList.contains(D); this._queueCallback(() => this._destroyElement(), this._element, y) } _destroyElement() { this._element.remove(), o.default.trigger(this._element, b), this.dispose() } static jQueryInterface(g) { return this.each(function () { let y = _.getOrCreateInstance(this); if (typeof g == "string") { if (y[g] === void 0 || g.startsWith("_") || g === "constructor") throw new TypeError(`No method named "${g}"`); y[g](this) } }) } } return tt(_, "close"), J(_), _ }) }); var Ii = Ht((An, Tn) => { (function (t, e) { typeof An == "object" && typeof Tn != "undefined" ? Tn.exports = e(Ut(), Qt()) : typeof define == "function" && define.amd ? define(["./dom/event-handler", "./base-component"], e) : (t = typeof globalThis != "undefined" ? globalThis : t || self, t.Button = e(t.EventHandler, t.Base)) })(An, function (t, e) { "use strict"; let n = b => b && typeof b == "object" && "default" in b ? b : { default: b }, o = n(t), r = n(e), i = () => { let { jQuery: b } = window; return b && !document.body.hasAttribute("data-bs-no-jquery") ? b : null }, c = [], s = b => { document.readyState === "loading" ? (c.length || document.addEventListener("DOMContentLoaded", () => { c.forEach(D => D()) }), c.push(b)) : b() }, E = b => { s(() => { let D = i(); if (D) { let q = b.NAME, _ = D.fn[q]; D.fn[q] = b.jQueryInterface, D.fn[q].Constructor = b, D.fn[q].noConflict = () => (D.fn[q] = _, b.jQueryInterface) } }) }, S = "button", J = ".bs.button", tt = ".data-api", Y = "active", X = '[data-bs-toggle="button"]', T = `click${J}${tt}`; class O extends r.default { static get NAME() { return S } toggle() { this._element.setAttribute("aria-pressed", this._element.classList.toggle(Y)) } static jQueryInterface(D) { return this.each(function () { let q = O.getOrCreateInstance(this); D === "toggle" && q[D]() }) } } return o.default.on(document, T, X, b => { b.preventDefault(); let D = b.target.closest(X); O.getOrCreateInstance(D).toggle() }), E(O), O }) }); var ne = Ht((bn, Cn) => { (function (t, e) { typeof bn == "object" && typeof Cn != "undefined" ? Cn.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis != "undefined" ? globalThis : t || self, t.Manipulator = e()) })(bn, function () { "use strict"; function t(o) { return o === "true" ? !0 : o === "false" ? !1 : o === Number(o).toString() ? Number(o) : o === "" || o === "null" ? null : o } function e(o) { return o.replace(/[A-Z]/g, r => `-${r.toLowerCase()}`) } return { setDataAttribute(o, r, i) { o.setAttribute(`data-bs-${e(r)}`, i) }, removeDataAttribute(o, r) { o.removeAttribute(`data-bs-${e(r)}`) }, getDataAttributes(o) { if (!o) return {}; let r = {}; return Object.keys(o.dataset).filter(i => i.startsWith("bs")).forEach(i => { let c = i.replace(/^bs/, ""); c = c.charAt(0).toLowerCase() + c.slice(1, c.length), r[c] = t(o.dataset[i]) }), r }, getDataAttribute(o, r) { return t(o.getAttribute(`data-bs-${e(r)}`)) }, offset(o) { let r = o.getBoundingClientRect(); return { top: r.top + window.pageYOffset, left: r.left + window.pageXOffset } }, position(o) { return { top: o.offsetTop, left: o.offsetLeft } } } }) }); var ie = Ht((On, wn) => { (function (t, e) { typeof On == "object" && typeof wn != "undefined" ? wn.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis != "undefined" ? globalThis : t || self, t.SelectorEngine = e()) })(On, function () { "use strict"; let t = i => !i || typeof i != "object" ? !1 : (typeof i.jquery != "undefined" && (i = i[0]), typeof i.nodeType != "undefined"), e = i => !t(i) || i.getClientRects().length === 0 ? !1 : getComputedStyle(i).getPropertyValue("visibility") === "visible", n = i => !i || i.nodeType !== Node.ELEMENT_NODE || i.classList.contains("disabled") ? !0 : typeof i.disabled != "undefined" ? i.disabled : i.hasAttribute("disabled") && i.getAttribute("disabled") !== "false", o = 3; return { find(i, c = document.documentElement) { return [].concat(...Element.prototype.querySelectorAll.call(c, i)) }, findOne(i, c = document.documentElement) { return Element.prototype.querySelector.call(c, i) }, children(i, c) { return [].concat(...i.children).filter(s => s.matches(c)) }, parents(i, c) { let s = [], E = i.parentNode; for (; E && E.nodeType === Node.ELEMENT_NODE && E.nodeType !== o;)E.matches(c) && s.push(E), E = E.parentNode; return s }, prev(i, c) { let s = i.previousElementSibling; for (; s;) { if (s.matches(c)) return [s]; s = s.previousElementSibling } return [] }, next(i, c) { let s = i.nextElementSibling; for (; s;) { if (s.matches(c)) return [s]; s = s.nextElementSibling } return [] }, focusableChildren(i) { let c = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(s => `${s}:not([tabindex^="-"])`).join(", "); return this.find(c, i).filter(s => !n(s) && e(s)) } } }) }); var xi = Ht((Sn, Nn) => { (function (t, e) { typeof Sn == "object" && typeof Nn != "undefined" ? Nn.exports = e(Ut(), ne(), ie(), Qt()) : typeof define == "function" && define.amd ? define(["./dom/event-handler", "./dom/manipulator", "./dom/selector-engine", "./base-component"], e) : (t = typeof globalThis != "undefined" ? globalThis : t || self, t.Carousel = e(t.EventHandler, t.Manipulator, t.SelectorEngine, t.Base)) })(Sn, function (t, e, n, o) { "use strict"; let r = I => I && typeof I == "object" && "default" in I ? I : { default: I }, i = r(t), c = r(e), s = r(n), E = r(o), S = "transitionend", v = I => I == null ? `${I}` : {}.toString.call(I).match(/\s([a-z]+)/i)[1].toLowerCase(), J = I => { let m = I.getAttribute("data-bs-target"); if (!m || m === "#") { let H = I.getAttribute("href"); if (!H || !H.includes("#") && !H.startsWith(".")) return null; H.includes("#") && !H.startsWith("#") && (H = `#${H.split("#")[1]}`), m = H && H !== "#" ? H.trim() : null } return m }, tt = I => { let m = J(I); return m ? document.querySelector(m) : null }, Y = I => { I.dispatchEvent(new Event(S)) }, X = I => !I || typeof I != "object" ? !1 : (typeof I.jquery != "undefined" && (I = I[0]), typeof I.nodeType != "undefined"), T = (I, m, H) => { Object.keys(H).forEach(it => { let dt = H[it], ot = m[it], C = ot && X(ot) ? "element" : v(ot); if (!new RegExp(dt).test(C)) throw new TypeError(`${I.toUpperCase()}: Option "${it}" provided type "${C}" but expected type "${dt}".`) }) }, O = I => !X(I) || I.getClientRects().length === 0 ? !1 : getComputedStyle(I).getPropertyValue("visibility") === "visible", b = I => { I.offsetHeight }, D = () => { let { jQuery: I } = window; return I && !document.body.hasAttribute("data-bs-no-jquery") ? I : null }, q = [], _ = I => { document.readyState === "loading" ? (q.length || document.addEventListener("DOMContentLoaded", () => { q.forEach(m => m()) }), q.push(I)) : I() }, l = () => document.documentElement.dir === "rtl", g = I => { _(() => { let m = D(); if (m) { let H = I.NAME, it = m.fn[H]; m.fn[H] = I.jQueryInterface, m.fn[H].Constructor = I, m.fn[H].noConflict = () => (m.fn[H] = it, I.jQueryInterface) } }) }, y = (I, m, H, it) => { let dt = I.indexOf(m); if (dt === -1) return I[!H && it ? I.length - 1 : 0]; let ot = I.length; return dt += H ? 1 : -1, it && (dt = (dt + ot) % ot), I[Math.max(0, Math.min(dt, ot - 1))] }, W = "carousel", P = ".bs.carousel", F = ".data-api", st = "ArrowLeft", et = "ArrowRight", gt = 500, ct = 40, nt = { interval: 5e3, keyboard: !0, slide: !1, pause: "hover", wrap: !0, touch: !0 }, pt = { interval: "(number|boolean)", keyboard: "boolean", slide: "(boolean|string)", pause: "(string|boolean)", wrap: "boolean", touch: "boolean" }, Et = "next", Z = "prev", B = "left", p = "right", A = { [st]: p, [et]: B }, Q = `slide${P}`, rt = `slid${P}`, k = `keydown${P}`, M = `mouseenter${P}`, z = `mouseleave${P}`, mt = `touchstart${P}`, w = `touchmove${P}`, L = `touchend${P}`, K = `pointerdown${P}`, ft = `pointerup${P}`, St = `dragstart${P}`, yt = `load${P}${F}`, Ot = `click${P}${F}`, wt = "carousel", vt = "active", Dt = "slide", Pt = "carousel-item-end", R = "carousel-item-start", a = "carousel-item-next", u = "carousel-item-prev", ut = "pointer-event", lt = ".active", Tt = ".active.carousel-item", bt = ".carousel-item", x = ".carousel-item img", h = ".carousel-item-next, .carousel-item-prev", U = ".carousel-indicators", _t = "[data-bs-target]", Ct = "[data-bs-slide], [data-bs-slide-to]", ht = '[data-bs-ride="carousel"]', N = "touch", d = "pen"; class $ extends E.default { constructor(m, H) { super(m); this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(H), this._indicatorsElement = s.default.findOne(U, this._element), this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent), this._addEventListeners() } static get Default() { return nt } static get NAME() { return W } next() { this._slide(Et) } nextWhenVisible() { !document.hidden && O(this._element) && this.next() } prev() { this._slide(Z) } pause(m) { m || (this._isPaused = !0), s.default.findOne(h, this._element) && (Y(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null } cycle(m) { m || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval)) } to(m) { this._activeElement = s.default.findOne(Tt, this._element); let H = this._getItemIndex(this._activeElement); if (m > this._items.length - 1 || m < 0) return; if (this._isSliding) { i.default.one(this._element, rt, () => this.to(m)); return } if (H === m) { this.pause(), this.cycle(); return } let it = m > H ? Et : Z; this._slide(it, this._items[m]) } _getConfig(m) { return m = { ...nt, ...c.default.getDataAttributes(this._element), ...typeof m == "object" ? m : {} }, T(W, m, pt), m } _handleSwipe() { let m = Math.abs(this.touchDeltaX); if (m <= ct) return; let H = m / this.touchDeltaX; this.touchDeltaX = 0, !!H && this._slide(H > 0 ? p : B) } _addEventListeners() { this._config.keyboard && i.default.on(this._element, k, m => this._keydown(m)), this._config.pause === "hover" && (i.default.on(this._element, M, m => this.pause(m)), i.default.on(this._element, z, m => this.cycle(m))), this._config.touch && this._touchSupported && this._addTouchEventListeners() } _addTouchEventListeners() { let m = ot => this._pointerEvent && (ot.pointerType === d || ot.pointerType === N), H = ot => { m(ot) ? this.touchStartX = ot.clientX : this._pointerEvent || (this.touchStartX = ot.touches[0].clientX) }, it = ot => { this.touchDeltaX = ot.touches && ot.touches.length > 1 ? 0 : ot.touches[0].clientX - this.touchStartX }, dt = ot => { m(ot) && (this.touchDeltaX = ot.clientX - this.touchStartX), this._handleSwipe(), this._config.pause === "hover" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(C => this.cycle(C), gt + this._config.interval)) }; s.default.find(x, this._element).forEach(ot => { i.default.on(ot, St, C => C.preventDefault()) }), this._pointerEvent ? (i.default.on(this._element, K, ot => H(ot)), i.default.on(this._element, ft, ot => dt(ot)), this._element.classList.add(ut)) : (i.default.on(this._element, mt, ot => H(ot)), i.default.on(this._element, w, ot => it(ot)), i.default.on(this._element, L, ot => dt(ot))) } _keydown(m) { if (/input|textarea/i.test(m.target.tagName)) return; let H = A[m.key]; H && (m.preventDefault(), this._slide(H)) } _getItemIndex(m) { return this._items = m && m.parentNode ? s.default.find(bt, m.parentNode) : [], this._items.indexOf(m) } _getItemByOrder(m, H) { let it = m === Et; return y(this._items, H, it, this._config.wrap) } _triggerSlideEvent(m, H) { let it = this._getItemIndex(m), dt = this._getItemIndex(s.default.findOne(Tt, this._element)); return i.default.trigger(this._element, Q, { relatedTarget: m, direction: H, from: dt, to: it }) } _setActiveIndicatorElement(m) { if (this._indicatorsElement) { let H = s.default.findOne(lt, this._indicatorsElement); H.classList.remove(vt), H.removeAttribute("aria-current"); let it = s.default.find(_t, this._indicatorsElement); for (let dt = 0; dt < it.length; dt++)if (Number.parseInt(it[dt].getAttribute("data-bs-slide-to"), 10) === this._getItemIndex(m)) { it[dt].classList.add(vt), it[dt].setAttribute("aria-current", "true"); break } } } _updateInterval() { let m = this._activeElement || s.default.findOne(Tt, this._element); if (!m) return; let H = Number.parseInt(m.getAttribute("data-bs-interval"), 10); H ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = H) : this._config.interval = this._config.defaultInterval || this._config.interval } _slide(m, H) { let it = this._directionToOrder(m), dt = s.default.findOne(Tt, this._element), ot = this._getItemIndex(dt), C = H || this._getItemByOrder(it, dt), f = this._getItemIndex(C), V = Boolean(this._interval), at = it === Et, At = at ? R : Pt, It = at ? a : u, qt = this._orderToDirection(it); if (C && C.classList.contains(vt)) { this._isSliding = !1; return } if (this._isSliding || this._triggerSlideEvent(C, qt).defaultPrevented || !dt || !C) return; this._isSliding = !0, V && this.pause(), this._setActiveIndicatorElement(C), this._activeElement = C; let wi = () => { i.default.trigger(this._element, rt, { relatedTarget: C, direction: qt, from: ot, to: f }) }; if (this._element.classList.contains(Dt)) { C.classList.add(It), b(C), dt.classList.add(At), C.classList.add(At); let wr = () => { C.classList.remove(At, It), C.classList.add(vt), dt.classList.remove(vt, It, At), this._isSliding = !1, setTimeout(wi, 0) }; this._queueCallback(wr, dt, !0) } else dt.classList.remove(vt), C.classList.add(vt), this._isSliding = !1, wi(); V && this.cycle() } _directionToOrder(m) { return [p, B].includes(m) ? l() ? m === B ? Z : Et : m === B ? Et : Z : m } _orderToDirection(m) { return [Et, Z].includes(m) ? l() ? m === Z ? B : p : m === Z ? p : B : m } static carouselInterface(m, H) { let it = $.getOrCreateInstance(m, H), { _config: dt } = it; typeof H == "object" && (dt = { ...dt, ...H }); let ot = typeof H == "string" ? H : dt.slide; if (typeof H == "number") it.to(H); else if (typeof ot == "string") { if (typeof it[ot] == "undefined") throw new TypeError(`No method named "${ot}"`); it[ot]() } else dt.interval && dt.ride && (it.pause(), it.cycle()) } static jQueryInterface(m) { return this.each(function () { $.carouselInterface(this, m) }) } static dataApiClickHandler(m) { let H = tt(this); if (!H || !H.classList.contains(wt)) return; let it = { ...c.default.getDataAttributes(H), ...c.default.getDataAttributes(this) }, dt = this.getAttribute("data-bs-slide-to"); dt && (it.interval = !1), $.carouselInterface(H, it), dt && $.getInstance(H).to(dt), m.preventDefault() } } return i.default.on(document, Ot, Ct, $.dataApiClickHandler), i.default.on(window, yt, () => { let I = s.default.find(ht); for (let m = 0, H = I.length; m < H; m++)$.carouselInterface(I[m], $.getInstance(I[m])) }), g($), $ }) }); var Mi = Ht((Dn, Ln) => { (function (t, e) { typeof Dn == "object" && typeof Ln != "undefined" ? Ln.exports = e(Fe(), Ut(), ne(), ie(), Qt()) : typeof define == "function" && define.amd ? define(["./dom/data", "./dom/event-handler", "./dom/manipulator", "./dom/selector-engine", "./base-component"], e) : (t = typeof globalThis != "undefined" ? globalThis : t || self, t.Collapse = e(t.Data, t.EventHandler, t.Manipulator, t.SelectorEngine, t.Base)) })(Dn, function (t, e, n, o, r) { "use strict"; let i = w => w && typeof w == "object" && "default" in w ? w : { default: w }, c = i(t), s = i(e), E = i(n), S = i(o), v = i(r), J = w => w == null ? `${w}` : {}.toString.call(w).match(/\s([a-z]+)/i)[1].toLowerCase(), tt = w => { let L = w.getAttribute("data-bs-target"); if (!L || L === "#") { let K = w.getAttribute("href"); if (!K || !K.includes("#") && !K.startsWith(".")) return null; K.includes("#") && !K.startsWith("#") && (K = `#${K.split("#")[1]}`), L = K && K !== "#" ? K.trim() : null } return L }, Y = w => { let L = tt(w); return L && document.querySelector(L) ? L : null }, X = w => { let L = tt(w); return L ? document.querySelector(L) : null }, T = w => !w || typeof w != "object" ? !1 : (typeof w.jquery != "undefined" && (w = w[0]), typeof w.nodeType != "undefined"), O = w => T(w) ? w.jquery ? w[0] : w : typeof w == "string" && w.length > 0 ? document.querySelector(w) : null, b = (w, L, K) => { Object.keys(K).forEach(ft => { let St = K[ft], yt = L[ft], Ot = yt && T(yt) ? "element" : J(yt); if (!new RegExp(St).test(Ot)) throw new TypeError(`${w.toUpperCase()}: Option "${ft}" provided type "${Ot}" but expected type "${St}".`) }) }, D = w => { w.offsetHeight }, q = () => { let { jQuery: w } = window; return w && !document.body.hasAttribute("data-bs-no-jquery") ? w : null }, _ = [], l = w => { document.readyState === "loading" ? (_.length || document.addEventListener("DOMContentLoaded", () => { _.forEach(L => L()) }), _.push(w)) : w() }, g = w => { l(() => { let L = q(); if (L) { let K = w.NAME, ft = L.fn[K]; L.fn[K] = w.jQueryInterface, L.fn[K].Constructor = w, L.fn[K].noConflict = () => (L.fn[K] = ft, w.jQueryInterface) } }) }, y = "collapse", W = "bs.collapse", j = `.${W}`, P = ".data-api", F = { toggle: !0, parent: null }, st = { toggle: "boolean", parent: "(null|element)" }, et = `show${j}`, gt = `shown${j}`, ct = `hide${j}`, nt = `hidden${j}`, pt = `click${j}${P}`, Et = "show", Z = "collapse", B = "collapsing", p = "collapsed", A = `:scope .${Z} .${Z}`, Q = "collapse-horizontal", rt = "width", k = "height", M = ".collapse.show, .collapse.collapsing", z = '[data-bs-toggle="collapse"]'; class mt extends v.default { constructor(L, K) { super(L); this._isTransitioning = !1, this._config = this._getConfig(K), this._triggerArray = []; let ft = S.default.find(z); for (let St = 0, yt = ft.length; St < yt; St++) { let Ot = ft[St], wt = Y(Ot), vt = S.default.find(wt).filter(Dt => Dt === this._element); wt !== null && vt.length && (this._selector = wt, this._triggerArray.push(Ot)) } this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle() } static get Default() { return F } static get NAME() { return y } toggle() { this._isShown() ? this.hide() : this.show() } show() { if (this._isTransitioning || this._isShown()) return; let L = [], K; if (this._config.parent) { let Dt = S.default.find(A, this._config.parent); L = S.default.find(M, this._config.parent).filter(Pt => !Dt.includes(Pt)) } let ft = S.default.findOne(this._selector); if (L.length) { let Dt = L.find(Pt => ft !== Pt); if (K = Dt ? mt.getInstance(Dt) : null, K && K._isTransitioning) return } if (s.default.trigger(this._element, et).defaultPrevented) return; L.forEach(Dt => { ft !== Dt && mt.getOrCreateInstance(Dt, { toggle: !1 }).hide(), K || c.default.set(Dt, W, null) }); let yt = this._getDimension(); this._element.classList.remove(Z), this._element.classList.add(B), this._element.style[yt] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0; let Ot = () => { this._isTransitioning = !1, this._element.classList.remove(B), this._element.classList.add(Z, Et), this._element.style[yt] = "", s.default.trigger(this._element, gt) }, vt = `scroll${yt[0].toUpperCase() + yt.slice(1)}`; this._queueCallback(Ot, this._element, !0), this._element.style[yt] = `${this._element[vt]}px` } hide() { if (this._isTransitioning || !this._isShown() || s.default.trigger(this._element, ct).defaultPrevented) return; let K = this._getDimension(); this._element.style[K] = `${this._element.getBoundingClientRect()[K]}px`, D(this._element), this._element.classList.add(B), this._element.classList.remove(Z, Et); let ft = this._triggerArray.length; for (let yt = 0; yt < ft; yt++) { let Ot = this._triggerArray[yt], wt = X(Ot); wt && !this._isShown(wt) && this._addAriaAndCollapsedClass([Ot], !1) } this._isTransitioning = !0; let St = () => { this._isTransitioning = !1, this._element.classList.remove(B), this._element.classList.add(Z), s.default.trigger(this._element, nt) }; this._element.style[K] = "", this._queueCallback(St, this._element, !0) } _isShown(L = this._element) { return L.classList.contains(Et) } _getConfig(L) { return L = { ...F, ...E.default.getDataAttributes(this._element), ...L }, L.toggle = Boolean(L.toggle), L.parent = O(L.parent), b(y, L, st), L } _getDimension() { return this._element.classList.contains(Q) ? rt : k } _initializeChildren() { if (!this._config.parent) return; let L = S.default.find(A, this._config.parent); S.default.find(z, this._config.parent).filter(K => !L.includes(K)).forEach(K => { let ft = X(K); ft && this._addAriaAndCollapsedClass([K], this._isShown(ft)) }) } _addAriaAndCollapsedClass(L, K) { !L.length || L.forEach(ft => { K ? ft.classList.remove(p) : ft.classList.add(p), ft.setAttribute("aria-expanded", K) }) } static jQueryInterface(L) { return this.each(function () { let K = {}; typeof L == "string" && /show|hide/.test(L) && (K.toggle = !1); let ft = mt.getOrCreateInstance(this, K); if (typeof L == "string") { if (typeof ft[L] == "undefined") throw new TypeError(`No method named "${L}"`); ft[L]() } }) } } return s.default.on(document, pt, z, function (w) { (w.target.tagName === "A" || w.delegateTarget && w.delegateTarget.tagName === "A") && w.preventDefault(); let L = Y(this); S.default.find(L).forEach(ft => { mt.getOrCreateInstance(ft, { toggle: !1 }).toggle() }) }), g(mt), mt }) }); var Nt, Rt, xt, Lt, Me, re, Zt, ce, In, Re, pe, xn, Ye, Pe, Ri, Pi, $i, ki, Vi, Hi, Bi, Wi, qi, Ke, Wt = G(() => { Nt = "top", Rt = "bottom", xt = "right", Lt = "left", Me = "auto", re = [Nt, Rt, xt, Lt], Zt = "start", ce = "end", In = "clippingParents", Re = "viewport", pe = "popper", xn = "reference", Ye = re.reduce(function (t, e) { return t.concat([e + "-" + Zt, e + "-" + ce]) }, []), Pe = [].concat(re, [Me]).reduce(function (t, e) { return t.concat([e, e + "-" + Zt, e + "-" + ce]) }, []), Ri = "beforeRead", Pi = "read", $i = "afterRead", ki = "beforeMain", Vi = "main", Hi = "afterMain", Bi = "beforeWrite", Wi = "write", qi = "afterWrite", Ke = [Ri, Pi, $i, ki, Vi, Hi, Bi, Wi, qi] }); function kt(t) { return t ? (t.nodeName || "").toLowerCase() : null } var ue = G(() => { }); function Mt(t) { if (t == null) return window; if (t.toString() !== "[object Window]") { var e = t.ownerDocument; return e && e.defaultView || window } return t } var te = G(() => { }); function ee(t) { var e = Mt(t).Element; return t instanceof e || t instanceof Element } function $t(t) { var e = Mt(t).HTMLElement; return t instanceof e || t instanceof HTMLElement } function Ue(t) { if (typeof ShadowRoot == "undefined") return !1; var e = Mt(t).ShadowRoot; return t instanceof e || t instanceof ShadowRoot } var Yt = G(() => { te() }); function Mr(t) { var e = t.state; Object.keys(e.elements).forEach(function (n) { var o = e.styles[n] || {}, r = e.attributes[n] || {}, i = e.elements[n]; !$t(i) || !kt(i) || (Object.assign(i.style, o), Object.keys(r).forEach(function (c) { var s = r[c]; s === !1 ? i.removeAttribute(c) : i.setAttribute(c, s === !0 ? "" : s) })) }) } function Rr(t) { var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function () { Object.keys(e.elements).forEach(function (o) { var r = e.elements[o], i = e.attributes[o] || {}, c = Object.keys(e.styles.hasOwnProperty(o) ? e.styles[o] : n[o]), s = c.reduce(function (E, S) { return E[S] = "", E }, {}); !$t(r) || !kt(r) || (Object.assign(r.style, s), Object.keys(i).forEach(function (E) { r.removeAttribute(E) })) }) } } var be, Qe = G(() => { ue(); Yt(); be = { name: "applyStyles", enabled: !0, phase: "write", fn: Mr, effect: Rr, requires: ["computeStyles"] } }); function Vt(t) { return t.split("-")[0] } var oe = G(() => { Wt() }); var Xt, he, se, fe = G(() => { Xt = Math.max, he = Math.min, se = Math.round }); function zt(t, e) { e === void 0 && (e = !1); var n = t.getBoundingClientRect(), o = 1, r = 1; if ($t(t) && e) { var i = t.offsetHeight, c = t.offsetWidth; c > 0 && (o = se(n.width) / c || 1), i > 0 && (r = se(n.height) / i || 1) } return { width: n.width / o, height: n.height / r, top: n.top / r, right: n.right / o, bottom: n.bottom / r, left: n.left / o, x: n.left / o, y: n.top / r } } var Ce = G(() => { Yt(); fe() }); function me(t) { var e = zt(t), n = t.offsetWidth, o = t.offsetHeight; return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - o) <= 1 && (o = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: o } } var ze = G(() => { Ce() }); function $e(t, e) { var n = e.getRootNode && e.getRootNode(); if (t.contains(e)) return !0; if (n && Ue(n)) { var o = e; do { if (o && t.isSameNode(o)) return !0; o = o.parentNode || o.host } while (o) } return !1 } var Mn = G(() => { Yt() }); function jt(t) { return Mt(t).getComputedStyle(t) } var _e = G(() => { te() }); function Rn(t) { return ["table", "td", "th"].indexOf(kt(t)) >= 0 } var ji = G(() => { ue() }); function Bt(t) { return ((ee(t) ? t.ownerDocument : t.document) || window.document).documentElement } var ae = G(() => { Yt() }); function le(t) { return kt(t) === "html" ? t : t.assignedSlot || t.parentNode || (Ue(t) ? t.host : null) || Bt(t) } var ke = G(() => { ue(); ae(); Yt() }); function Fi(t) { return !$t(t) || jt(t).position === "fixed" ? null : t.offsetParent } function Pr(t) { var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1; if (n && $t(t)) { var o = jt(t); if (o.position === "fixed") return null } for (var r = le(t); $t(r) && ["html", "body"].indexOf(kt(r)) < 0;) { var i = jt(r); if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none") return r; r = r.parentNode } return null } function Jt(t) { for (var e = Mt(t), n = Fi(t); n && Rn(n) && jt(n).position === "static";)n = Fi(n); return n && (kt(n) === "html" || kt(n) === "body" && jt(n).position === "static") ? e : n || Pr(t) || e } var Oe = G(() => { te(); ue(); _e(); Yt(); ji(); ke() }); function ge(t) { return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y" } var Ge = G(() => { }); function Ee(t, e, n) { return Xt(t, he(e, n)) } function Yi(t, e, n) { var o = Ee(t, e, n); return o > n ? n : o } var Pn = G(() => { fe() }); function Ve() { return { top: 0, right: 0, bottom: 0, left: 0 } } var $n = G(() => { }); function He(t) { return Object.assign({}, Ve(), t) } var kn = G(() => { $n() }); function Be(t, e) { return e.reduce(function (n, o) { return n[o] = t, n }, {}) } var Vn = G(() => { }); function kr(t) { var e, n = t.state, o = t.name, r = t.options, i = n.elements.arrow, c = n.modifiersData.popperOffsets, s = Vt(n.placement), E = ge(s), S = [Lt, xt].indexOf(s) >= 0, v = S ? "height" : "width"; if (!(!i || !c)) { var J = $r(r.padding, n), tt = me(i), Y = E === "y" ? Nt : Lt, X = E === "y" ? Rt : xt, T = n.rects.reference[v] + n.rects.reference[E] - c[E] - n.rects.popper[v], O = c[E] - n.rects.reference[E], b = Jt(i), D = b ? E === "y" ? b.clientHeight || 0 : b.clientWidth || 0 : 0, q = T / 2 - O / 2, _ = J[Y], l = D - tt[v] - J[X], g = D / 2 - tt[v] / 2 + q, y = Ee(_, g, l), W = E; n.modifiersData[o] = (e = {}, e[W] = y, e.centerOffset = y - g, e) } } function Vr(t) { var e = t.state, n = t.options, o = n.element, r = o === void 0 ? "[data-popper-arrow]" : o; r != null && (typeof r == "string" && (r = e.elements.popper.querySelector(r), !r) || !$e(e.elements.popper, r) || (e.elements.arrow = r)) } var $r, Xe, Hn = G(() => { oe(); ze(); Mn(); Oe(); Ge(); Pn(); kn(); Vn(); Wt(); Yt(); $r = function (e, n) { return e = typeof e == "function" ? e(Object.assign({}, n.rects, { placement: n.placement })) : e, He(typeof e != "number" ? e : Be(e, re)) }; Xe = { name: "arrow", enabled: !0, phase: "main", fn: kr, effect: Vr, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] } }); function Gt(t) { return t.split("-")[1] } var we = G(() => { }); function Br(t) { var e = t.x, n = t.y, o = window, r = o.devicePixelRatio || 1; return { x: se(e * r) / r || 0, y: se(n * r) / r || 0 } } function Ki(t) { var e, n = t.popper, o = t.popperRect, r = t.placement, i = t.variation, c = t.offsets, s = t.position, E = t.gpuAcceleration, S = t.adaptive, v = t.roundOffsets, J = t.isFixed, tt = c.x, Y = tt === void 0 ? 0 : tt, X = c.y, T = X === void 0 ? 0 : X, O = typeof v == "function" ? v({ x: Y, y: T }) : { x: Y, y: T }; Y = O.x, T = O.y; var b = c.hasOwnProperty("x"), D = c.hasOwnProperty("y"), q = Lt, _ = Nt, l = window; if (S) { var g = Jt(n), y = "clientHeight", W = "clientWidth"; if (g === Mt(n) && (g = Bt(n), jt(g).position !== "static" && s === "absolute" && (y = "scrollHeight", W = "scrollWidth")), g = g, r === Nt || (r === Lt || r === xt) && i === ce) { _ = Rt; var j = J && l.visualViewport ? l.visualViewport.height : g[y]; T -= j - o.height, T *= E ? 1 : -1 } if (r === Lt || (r === Nt || r === Rt) && i === ce) { q = xt; var P = J && l.visualViewport ? l.visualViewport.width : g[W]; Y -= P - o.width, Y *= E ? 1 : -1 } } var F = Object.assign({ position: s }, S && Hr), st = v === !0 ? Br({ x: Y, y: T }) : { x: Y, y: T }; if (Y = st.x, T = st.y, E) { var et; return Object.assign({}, F, (et = {}, et[_] = D ? "0" : "", et[q] = b ? "0" : "", et.transform = (l.devicePixelRatio || 1) <= 1 ? "translate(" + Y + "px, " + T + "px)" : "translate3d(" + Y + "px, " + T + "px, 0)", et)) } return Object.assign({}, F, (e = {}, e[_] = D ? T + "px" : "", e[q] = b ? Y + "px" : "", e.transform = "", e)) } function Wr(t) { var e = t.state, n = t.options, o = n.gpuAcceleration, r = o === void 0 ? !0 : o, i = n.adaptive, c = i === void 0 ? !0 : i, s = n.roundOffsets, E = s === void 0 ? !0 : s; if (!1) var S; var v = { placement: Vt(e.placement), variation: Gt(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: r, isFixed: e.options.strategy === "fixed" }; e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, Ki(Object.assign({}, v, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: c, roundOffsets: E })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, Ki(Object.assign({}, v, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: E })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement }) } var Hr, Se, Je = G(() => { Wt(); Oe(); te(); ae(); _e(); oe(); we(); fe(); Hr = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; Se = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: Wr, data: {} } }); function qr(t) { var e = t.state, n = t.instance, o = t.options, r = o.scroll, i = r === void 0 ? !0 : r, c = o.resize, s = c === void 0 ? !0 : c, E = Mt(e.elements.popper), S = [].concat(e.scrollParents.reference, e.scrollParents.popper); return i && S.forEach(function (v) { v.addEventListener("scroll", n.update, Ze) }), s && E.addEventListener("resize", n.update, Ze), function () { i && S.forEach(function (v) { v.removeEventListener("scroll", n.update, Ze) }), s && E.removeEventListener("resize", n.update, Ze) } } var Ze, Ne, tn = G(() => { te(); Ze = { passive: !0 }; Ne = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: qr, data: {} } }); function De(t) { return t.replace(/left|right|bottom|top/g, function (e) { return jr[e] }) } var jr, Ui = G(() => { jr = { left: "right", right: "left", bottom: "top", top: "bottom" } }); function en(t) { return t.replace(/start|end/g, function (e) { return Fr[e] }) } var Fr, Qi = G(() => { Fr = { start: "end", end: "start" } }); function ve(t) { var e = Mt(t), n = e.pageXOffset, o = e.pageYOffset; return { scrollLeft: n, scrollTop: o } } var nn = G(() => { te() }); function ye(t) { return zt(Bt(t)).left + ve(t).scrollLeft } var rn = G(() => { Ce(); ae(); nn() }); function Bn(t) { var e = Mt(t), n = Bt(t), o = e.visualViewport, r = n.clientWidth, i = n.clientHeight, c = 0, s = 0; return o && (r = o.width, i = o.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (c = o.offsetLeft, s = o.offsetTop)), { width: r, height: i, x: c + ye(t), y: s } } var zi = G(() => { te(); ae(); rn() }); function Wn(t) { var e, n = Bt(t), o = ve(t), r = (e = t.ownerDocument) == null ? void 0 : e.body, i = Xt(n.scrollWidth, n.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0), c = Xt(n.scrollHeight, n.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0), s = -o.scrollLeft + ye(t), E = -o.scrollTop; return jt(r || n).direction === "rtl" && (s += Xt(n.clientWidth, r ? r.clientWidth : 0) - i), { width: i, height: c, x: s, y: E } } var Gi = G(() => { ae(); _e(); rn(); nn(); fe() }); function Ae(t) { var e = jt(t), n = e.overflow, o = e.overflowX, r = e.overflowY; return /auto|scroll|overlay|hidden/.test(n + r + o) } var on = G(() => { _e() }); function sn(t) { return ["html", "body", "#document"].indexOf(kt(t)) >= 0 ? t.ownerDocument.body : $t(t) && Ae(t) ? t : sn(le(t)) } var Xi = G(() => { ke(); on(); ue(); Yt() }); function de(t, e) { var n; e === void 0 && (e = []); var o = sn(t), r = o === ((n = t.ownerDocument) == null ? void 0 : n.body), i = Mt(o), c = r ? [i].concat(i.visualViewport || [], Ae(o) ? o : []) : o, s = e.concat(c); return r ? s : s.concat(de(le(c))) } var qn = G(() => { Xi(); ke(); te(); on() }); function Le(t) { return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height }) } var jn = G(() => { }); function Yr(t) { var e = zt(t); return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e } function Ji(t, e) { return e === Re ? Le(Bn(t)) : ee(e) ? Yr(e) : Le(Wn(Bt(t))) } function Kr(t) { var e = de(le(t)), n = ["absolute", "fixed"].indexOf(jt(t).position) >= 0, o = n && $t(t) ? Jt(t) : t; return ee(o) ? e.filter(function (r) { return ee(r) && $e(r, o) && kt(r) !== "body" }) : [] } function Fn(t, e, n) { var o = e === "clippingParents" ? Kr(t) : [].concat(e), r = [].concat(o, [n]), i = r[0], c = r.reduce(function (s, E) { var S = Ji(t, E); return s.top = Xt(S.top, s.top), s.right = he(S.right, s.right), s.bottom = he(S.bottom, s.bottom), s.left = Xt(S.left, s.left), s }, Ji(t, i)); return c.width = c.right - c.left, c.height = c.bottom - c.top, c.x = c.left, c.y = c.top, c } var Zi = G(() => { Wt(); zi(); Gi(); qn(); Oe(); ae(); _e(); Yt(); Ce(); ke(); Mn(); ue(); jn(); fe() }); function We(t) { var e = t.reference, n = t.element, o = t.placement, r = o ? Vt(o) : null, i = o ? Gt(o) : null, c = e.x + e.width / 2 - n.width / 2, s = e.y + e.height / 2 - n.height / 2, E; switch (r) { case Nt: E = { x: c, y: e.y - n.height }; break; case Rt: E = { x: c, y: e.y + e.height }; break; case xt: E = { x: e.x + e.width, y: s }; break; case Lt: E = { x: e.x - n.width, y: s }; break; default: E = { x: e.x, y: e.y } }var S = r ? ge(r) : null; if (S != null) { var v = S === "y" ? "height" : "width"; switch (i) { case Zt: E[S] = E[S] - (e[v] / 2 - n[v] / 2); break; case ce: E[S] = E[S] + (e[v] / 2 - n[v] / 2); break; default: } } return E } var Yn = G(() => { oe(); we(); Ge(); Wt() }); function Ft(t, e) { e === void 0 && (e = {}); var n = e, o = n.placement, r = o === void 0 ? t.placement : o, i = n.boundary, c = i === void 0 ? In : i, s = n.rootBoundary, E = s === void 0 ? Re : s, S = n.elementContext, v = S === void 0 ? pe : S, J = n.altBoundary, tt = J === void 0 ? !1 : J, Y = n.padding, X = Y === void 0 ? 0 : Y, T = He(typeof X != "number" ? X : Be(X, re)), O = v === pe ? xn : pe, b = t.rects.popper, D = t.elements[tt ? O : v], q = Fn(ee(D) ? D : D.contextElement || Bt(t.elements.popper), c, E), _ = zt(t.elements.reference), l = We({ reference: _, element: b, strategy: "absolute", placement: r }), g = Le(Object.assign({}, b, l)), y = v === pe ? g : _, W = { top: q.top - y.top + T.top, bottom: y.bottom - q.bottom + T.bottom, left: q.left - y.left + T.left, right: y.right - q.right + T.right }, j = t.modifiersData.offset; if (v === pe && j) { var P = j[r]; Object.keys(W).forEach(function (F) { var st = [xt, Rt].indexOf(F) >= 0 ? 1 : -1, et = [Nt, Rt].indexOf(F) >= 0 ? "y" : "x"; W[F] += P[et] * st }) } return W } var Ie = G(() => { Zi(); ae(); Ce(); Yn(); jn(); Wt(); Yt(); kn(); Vn() }); function Kn(t, e) { e === void 0 && (e = {}); var n = e, o = n.placement, r = n.boundary, i = n.rootBoundary, c = n.padding, s = n.flipVariations, E = n.allowedAutoPlacements, S = E === void 0 ? Pe : E, v = Gt(o), J = v ? s ? Ye : Ye.filter(function (X) { return Gt(X) === v }) : re, tt = J.filter(function (X) { return S.indexOf(X) >= 0 }); tt.length === 0 && (tt = J); var Y = tt.reduce(function (X, T) { return X[T] = Ft(t, { placement: T, boundary: r, rootBoundary: i, padding: c })[Vt(T)], X }, {}); return Object.keys(Y).sort(function (X, T) { return Y[X] - Y[T] }) } var tr = G(() => { we(); Wt(); Ie(); oe() }); function Ur(t) { if (Vt(t) === Me) return []; var e = De(t); return [en(t), e, en(e)] } function Qr(t) { var e = t.state, n = t.options, o = t.name; if (!e.modifiersData[o]._skip) { for (var r = n.mainAxis, i = r === void 0 ? !0 : r, c = n.altAxis, s = c === void 0 ? !0 : c, E = n.fallbackPlacements, S = n.padding, v = n.boundary, J = n.rootBoundary, tt = n.altBoundary, Y = n.flipVariations, X = Y === void 0 ? !0 : Y, T = n.allowedAutoPlacements, O = e.options.placement, b = Vt(O), D = b === O, q = E || (D || !X ? [De(O)] : Ur(O)), _ = [O].concat(q).reduce(function (rt, k) { return rt.concat(Vt(k) === Me ? Kn(e, { placement: k, boundary: v, rootBoundary: J, padding: S, flipVariations: X, allowedAutoPlacements: T }) : k) }, []), l = e.rects.reference, g = e.rects.popper, y = new Map, W = !0, j = _[0], P = 0; P < _.length; P++) { var F = _[P], st = Vt(F), et = Gt(F) === Zt, gt = [Nt, Rt].indexOf(st) >= 0, ct = gt ? "width" : "height", nt = Ft(e, { placement: F, boundary: v, rootBoundary: J, altBoundary: tt, padding: S }), pt = gt ? et ? xt : Lt : et ? Rt : Nt; l[ct] > g[ct] && (pt = De(pt)); var Et = De(pt), Z = []; if (i && Z.push(nt[st] <= 0), s && Z.push(nt[pt] <= 0, nt[Et] <= 0), Z.every(function (rt) { return rt })) { j = F, W = !1; break } y.set(F, Z) } if (W) for (var B = X ? 3 : 1, p = function (k) { var M = _.find(function (z) { var mt = y.get(z); if (mt) return mt.slice(0, k).every(function (w) { return w }) }); if (M) return j = M, "break" }, A = B; A > 0; A--) { var Q = p(A); if (Q === "break") break } e.placement !== j && (e.modifiersData[o]._skip = !0, e.placement = j, e.reset = !0) } } var an, Un = G(() => { Ui(); oe(); Qi(); Ie(); tr(); Wt(); we(); an = { name: "flip", enabled: !0, phase: "main", fn: Qr, requiresIfExists: ["offset"], data: { _skip: !1 } } }); function er(t, e, n) { return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x } } function nr(t) { return [Nt, xt, Rt, Lt].some(function (e) { return t[e] >= 0 }) } function zr(t) { var e = t.state, n = t.name, o = e.rects.reference, r = e.rects.popper, i = e.modifiersData.preventOverflow, c = Ft(e, { elementContext: "reference" }), s = Ft(e, { altBoundary: !0 }), E = er(c, o), S = er(s, r, i), v = nr(E), J = nr(S); e.modifiersData[n] = { referenceClippingOffsets: E, popperEscapeOffsets: S, isReferenceHidden: v, hasPopperEscaped: J }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": v, "data-popper-escaped": J }) } var ln, Qn = G(() => { Wt(); Ie(); ln = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: zr } }); function Gr(t, e, n) { var o = Vt(t), r = [Lt, Nt].indexOf(o) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, c = i[0], s = i[1]; return c = c || 0, s = (s || 0) * r, [Lt, xt].indexOf(o) >= 0 ? { x: s, y: c } : { x: c, y: s } } function Xr(t) { var e = t.state, n = t.options, o = t.name, r = n.offset, i = r === void 0 ? [0, 0] : r, c = Pe.reduce(function (v, J) { return v[J] = Gr(J, e.rects, i), v }, {}), s = c[e.placement], E = s.x, S = s.y; e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += E, e.modifiersData.popperOffsets.y += S), e.modifiersData[o] = c } var cn, zn = G(() => { oe(); Wt(); cn = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: Xr } }); function Jr(t) { var e = t.state, n = t.name; e.modifiersData[n] = We({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement }) } var xe, un = G(() => { Yn(); xe = { name: "popperOffsets", enabled: !0, phase: "read", fn: Jr, data: {} } }); function Gn(t) { return t === "x" ? "y" : "x" } var ir = G(() => { }); function Zr(t) { var e = t.state, n = t.options, o = t.name, r = n.mainAxis, i = r === void 0 ? !0 : r, c = n.altAxis, s = c === void 0 ? !1 : c, E = n.boundary, S = n.rootBoundary, v = n.altBoundary, J = n.padding, tt = n.tether, Y = tt === void 0 ? !0 : tt, X = n.tetherOffset, T = X === void 0 ? 0 : X, O = Ft(e, { boundary: E, rootBoundary: S, padding: J, altBoundary: v }), b = Vt(e.placement), D = Gt(e.placement), q = !D, _ = ge(b), l = Gn(_), g = e.modifiersData.popperOffsets, y = e.rects.reference, W = e.rects.popper, j = typeof T == "function" ? T(Object.assign({}, e.rects, { placement: e.placement })) : T, P = typeof j == "number" ? { mainAxis: j, altAxis: j } : Object.assign({ mainAxis: 0, altAxis: 0 }, j), F = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, st = { x: 0, y: 0 }; if (!!g) { if (i) { var et, gt = _ === "y" ? Nt : Lt, ct = _ === "y" ? Rt : xt, nt = _ === "y" ? "height" : "width", pt = g[_], Et = pt + O[gt], Z = pt - O[ct], B = Y ? -W[nt] / 2 : 0, p = D === Zt ? y[nt] : W[nt], A = D === Zt ? -W[nt] : -y[nt], Q = e.elements.arrow, rt = Y && Q ? me(Q) : { width: 0, height: 0 }, k = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : Ve(), M = k[gt], z = k[ct], mt = Ee(0, y[nt], rt[nt]), w = q ? y[nt] / 2 - B - mt - M - P.mainAxis : p - mt - M - P.mainAxis, L = q ? -y[nt] / 2 + B + mt + z + P.mainAxis : A + mt + z + P.mainAxis, K = e.elements.arrow && Jt(e.elements.arrow), ft = K ? _ === "y" ? K.clientTop || 0 : K.clientLeft || 0 : 0, St = (et = F == null ? void 0 : F[_]) != null ? et : 0, yt = pt + w - St - ft, Ot = pt + L - St, wt = Ee(Y ? he(Et, yt) : Et, pt, Y ? Xt(Z, Ot) : Z); g[_] = wt, st[_] = wt - pt } if (s) { var vt, Dt = _ === "x" ? Nt : Lt, Pt = _ === "x" ? Rt : xt, R = g[l], a = l === "y" ? "height" : "width", u = R + O[Dt], ut = R - O[Pt], lt = [Nt, Lt].indexOf(b) !== -1, Tt = (vt = F == null ? void 0 : F[l]) != null ? vt : 0, bt = lt ? u : R - y[a] - W[a] - Tt + P.altAxis, x = lt ? R + y[a] + W[a] - Tt - P.altAxis : ut, h = Y && lt ? Yi(bt, R, x) : Ee(Y ? bt : u, R, Y ? x : ut); g[l] = h, st[l] = h - R } e.modifiersData[o] = st } } var fn, Xn = G(() => { Wt(); oe(); Ge(); ir(); Pn(); ze(); Oe(); Ie(); we(); $n(); fe(); fn = { name: "preventOverflow", enabled: !0, phase: "main", fn: Zr, requiresIfExists: ["offset"] } }); var Jn = G(() => { Qe(); Hn(); Je(); tn(); Un(); Qn(); zn(); un(); Xn() }); function Zn(t) { return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop } } var rr = G(() => { }); function ti(t) { return t === Mt(t) || !$t(t) ? ve(t) : Zn(t) } var or = G(() => { nn(); te(); Yt(); rr() }); function to(t) { var e = t.getBoundingClientRect(), n = se(e.width) / t.offsetWidth || 1, o = se(e.height) / t.offsetHeight || 1; return n !== 1 || o !== 1 } function ei(t, e, n) { n === void 0 && (n = !1); var o = $t(e), r = $t(e) && to(e), i = Bt(e), c = zt(t, r), s = { scrollLeft: 0, scrollTop: 0 }, E = { x: 0, y: 0 }; return (o || !o && !n) && ((kt(e) !== "body" || Ae(i)) && (s = ti(e)), $t(e) ? (E = zt(e, !0), E.x += e.clientLeft, E.y += e.clientTop) : i && (E.x = ye(i))), { x: c.left + s.scrollLeft - E.x, y: c.top + s.scrollTop - E.y, width: c.width, height: c.height } } var sr = G(() => { Ce(); or(); ue(); Yt(); rn(); ae(); on(); fe() }); function eo(t) { var e = new Map, n = new Set, o = []; t.forEach(function (i) { e.set(i.name, i) }); function r(i) { n.add(i.name); var c = [].concat(i.requires || [], i.requiresIfExists || []); c.forEach(function (s) { if (!n.has(s)) { var E = e.get(s); E && r(E) } }), o.push(i) } return t.forEach(function (i) { n.has(i.name) || r(i) }), o } function ni(t) { var e = eo(t); return Ke.reduce(function (n, o) { return n.concat(e.filter(function (r) { return r.phase === o })) }, []) } var ar = G(() => { Wt() }); function ii(t) { var e; return function () { return e || (e = new Promise(function (n) { Promise.resolve().then(function () { e = void 0, n(t()) }) })), e } } var lr = G(() => { }); var cr = G(() => { }); var ur = G(() => { cr(); Wt() }); var fr = G(() => { }); function ri(t) { var e = t.reduce(function (n, o) { var r = n[o.name]; return n[o.name] = r ? Object.assign({}, r, o, { options: Object.assign({}, r.options, o.options), data: Object.assign({}, r.data, o.data) }) : o, n }, {}); return Object.keys(e).map(function (n) { return e[n] }) } var dr = G(() => { }); function hr() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return !e.some(function (o) { return !(o && typeof o.getBoundingClientRect == "function") }) } function Te(t) { t === void 0 && (t = {}); var e = t, n = e.defaultModifiers, o = n === void 0 ? [] : n, r = e.defaultOptions, i = r === void 0 ? pr : r; return function (s, E, S) { S === void 0 && (S = i); var v = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, pr, i), modifiersData: {}, elements: { reference: s, popper: E }, attributes: {}, styles: {} }, J = [], tt = !1, Y = { state: v, setOptions: function (b) { var D = typeof b == "function" ? b(v.options) : b; T(), v.options = Object.assign({}, i, v.options, D), v.scrollParents = { reference: ee(s) ? de(s) : s.contextElement ? de(s.contextElement) : [], popper: de(E) }; var q = ni(ri([].concat(o, v.options.modifiers))); if (v.orderedModifiers = q.filter(function (F) { return F.enabled }), !1) { var _; if (tc(v.options.placement) === oc) var l; var g, y, W, j, P } return X(), Y.update() }, forceUpdate: function () { if (!tt) { var b = v.elements, D = b.reference, q = b.popper; if (!!hr(D, q)) { v.rects = { reference: ei(D, Jt(q), v.options.strategy === "fixed"), popper: me(q) }, v.reset = !1, v.placement = v.options.placement, v.orderedModifiers.forEach(function (F) { return v.modifiersData[F.name] = Object.assign({}, F.data) }); for (var _ = 0, l = 0; l < v.orderedModifiers.length; l++) { if (v.reset === !0) { v.reset = !1, l = -1; continue } var g = v.orderedModifiers[l], y = g.fn, W = g.options, j = W === void 0 ? {} : W, P = g.name; typeof y == "function" && (v = y({ state: v, options: j, name: P, instance: Y }) || v) } } } }, update: ii(function () { return new Promise(function (O) { Y.forceUpdate(), O(v) }) }), destroy: function () { T(), tt = !0 } }; if (!hr(s, E)) return Y; Y.setOptions(S).then(function (O) { !tt && S.onFirstUpdate && S.onFirstUpdate(O) }); function X() { v.orderedModifiers.forEach(function (O) { var b = O.name, D = O.options, q = D === void 0 ? {} : D, _ = O.effect; if (typeof _ == "function") { var l = _({ state: v, name: b, instance: Y, options: q }), g = function () { }; J.push(l || g) } }) } function T() { J.forEach(function (O) { return O() }), J = [] } return Y } } var pr, mr, dn = G(() => { sr(); ze(); qn(); Oe(); _e(); ar(); lr(); ur(); fr(); oe(); dr(); Ie(); Yt(); Wt(); pr = { placement: "bottom", modifiers: [], strategy: "absolute" }; mr = Te() }); var no, oi, si = G(() => { dn(); tn(); un(); Je(); Qe(); no = [Ne, xe, Se, be], oi = Te({ defaultModifiers: no }) }); var io, _r, gr = G(() => { dn(); tn(); un(); Je(); Qe(); zn(); Un(); Xn(); Hn(); Qn(); si(); Jn(); io = [Ne, xe, Se, be, cn, an, fn, Xe, ln], _r = Te({ defaultModifiers: io }) }); var Er = G(() => { Wt(); Jn(); dn(); gr(); si() }); var ai = {}; xr(ai, { afterMain: () => Hi, afterRead: () => $i, afterWrite: () => qi, applyStyles: () => be, arrow: () => Xe, auto: () => Me, basePlacements: () => re, beforeMain: () => ki, beforeRead: () => Ri, beforeWrite: () => Bi, bottom: () => Rt, clippingParents: () => In, computeStyles: () => Se, createPopper: () => _r, createPopperBase: () => mr, createPopperLite: () => oi, detectOverflow: () => Ft, end: () => ce, eventListeners: () => Ne, flip: () => an, hide: () => ln, left: () => Lt, main: () => Vi, modifierPhases: () => Ke, offset: () => cn, placements: () => Pe, popper: () => pe, popperGenerator: () => Te, popperOffsets: () => xe, preventOverflow: () => fn, read: () => Pi, reference: () => xn, right: () => xt, start: () => Zt, top: () => Nt, variationPlacements: () => Ye, viewport: () => Re, write: () => Wi }); var li = G(() => { Er() }); var vr = Ht((ci, ui) => { (function (t, e) { typeof ci == "object" && typeof ui != "undefined" ? ui.exports = e((li(), Di(ai)), Ut(), ne(), ie(), Qt()) : typeof define == "function" && define.amd ? define(["@popperjs/core", "./dom/event-handler", "./dom/manipulator", "./dom/selector-engine", "./base-component"], e) : (t = typeof globalThis != "undefined" ? globalThis : t || self, t.Dropdown = e(t.Popper, t.EventHandler, t.Manipulator, t.SelectorEngine, t.Base)) })(ci, function (t, e, n, o, r) { "use strict"; let i = x => x && typeof x == "object" && "default" in x ? x : { default: x }; function c(x) { if (x && x.__esModule) return x; let h = Object.create(null); if (x) { for (let U in x) if (U !== "default") { let _t = Object.getOwnPropertyDescriptor(x, U); Object.defineProperty(h, U, _t.get ? _t : { enumerable: !0, get: () => x[U] }) } } return h.default = x, Object.freeze(h) } let s = c(t), E = i(e), S = i(n), v = i(o), J = i(r), tt = x => x == null ? `${x}` : {}.toString.call(x).match(/\s([a-z]+)/i)[1].toLowerCase(), Y = x => { let h = x.getAttribute("data-bs-target"); if (!h || h === "#") { let U = x.getAttribute("href"); if (!U || !U.includes("#") && !U.startsWith(".")) return null; U.includes("#") && !U.startsWith("#") && (U = `#${U.split("#")[1]}`), h = U && U !== "#" ? U.trim() : null } return h }, X = x => { let h = Y(x); return h ? document.querySelector(h) : null }, T = x => !x || typeof x != "object" ? !1 : (typeof x.jquery != "undefined" && (x = x[0]), typeof x.nodeType != "undefined"), O = x => T(x) ? x.jquery ? x[0] : x : typeof x == "string" && x.length > 0 ? document.querySelector(x) : null, b = (x, h, U) => { Object.keys(U).forEach(_t => { let Ct = U[_t], ht = h[_t], N = ht && T(ht) ? "element" : tt(ht); if (!new RegExp(Ct).test(N)) throw new TypeError(`${x.toUpperCase()}: Option "${_t}" provided type "${N}" but expected type "${Ct}".`) }) }, D = x => !T(x) || x.getClientRects().length === 0 ? !1 : getComputedStyle(x).getPropertyValue("visibility") === "visible", q = x => !x || x.nodeType !== Node.ELEMENT_NODE || x.classList.contains("disabled") ? !0 : typeof x.disabled != "undefined" ? x.disabled : x.hasAttribute("disabled") && x.getAttribute("disabled") !== "false", _ = () => { }, l = () => { let { jQuery: x } = window; return x && !document.body.hasAttribute("data-bs-no-jquery") ? x : null }, g = [], y = x => { document.readyState === "loading" ? (g.length || document.addEventListener("DOMContentLoaded", () => { g.forEach(h => h()) }), g.push(x)) : x() }, W = () => document.documentElement.dir === "rtl", j = x => { y(() => { let h = l(); if (h) { let U = x.NAME, _t = h.fn[U]; h.fn[U] = x.jQueryInterface, h.fn[U].Constructor = x, h.fn[U].noConflict = () => (h.fn[U] = _t, x.jQueryInterface) } }) }, P = (x, h, U, _t) => { let Ct = x.indexOf(h); if (Ct === -1) return x[!U && _t ? x.length - 1 : 0]; let ht = x.length; return Ct += U ? 1 : -1, _t && (Ct = (Ct + ht) % ht), x[Math.max(0, Math.min(Ct, ht - 1))] }, F = "dropdown", et = ".bs.dropdown", gt = ".data-api", ct = "Escape", nt = "Space", pt = "Tab", Et = "ArrowUp", Z = "ArrowDown", B = 2, p = new RegExp(`${Et}|${Z}|${ct}`), A = `hide${et}`, Q = `hidden${et}`, rt = `show${et}`, k = `shown${et}`, M = `click${et}${gt}`, z = `keydown${et}${gt}`, mt = `keyup${et}${gt}`, w = "show", L = "dropup", K = "dropend", ft = "dropstart", St = "navbar", yt = '[data-bs-toggle="dropdown"]', Ot = ".dropdown-menu", wt = ".navbar-nav", vt = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", Dt = W() ? "top-end" : "top-start", Pt = W() ? "top-start" : "top-end", R = W() ? "bottom-end" : "bottom-start", a = W() ? "bottom-start" : "bottom-end", u = W() ? "left-start" : "right-start", ut = W() ? "right-start" : "left-start", lt = { offset: [0, 2], boundary: "clippingParents", reference: "toggle", display: "dynamic", popperConfig: null, autoClose: !0 }, Tt = { offset: "(array|string|function)", boundary: "(string|element)", reference: "(string|element|object)", display: "string", popperConfig: "(null|object|function)", autoClose: "(boolean|string)" }; class bt extends J.default { constructor(h, U) { super(h); this._popper = null, this._config = this._getConfig(U), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar() } static get Default() { return lt } static get DefaultType() { return Tt } static get NAME() { return F } toggle() { return this._isShown() ? this.hide() : this.show() } show() { if (q(this._element) || this._isShown(this._menu)) return; let h = { relatedTarget: this._element }; if (E.default.trigger(this._element, rt, h).defaultPrevented) return; let _t = bt.getParentFromElement(this._element); this._inNavbar ? S.default.setDataAttribute(this._menu, "popper", "none") : this._createPopper(_t), "ontouchstart" in document.documentElement && !_t.closest(wt) && [].concat(...document.body.children).forEach(Ct => E.default.on(Ct, "mouseover", _)), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(w), this._element.classList.add(w), E.default.trigger(this._element, k, h) } hide() { if (q(this._element) || !this._isShown(this._menu)) return; let h = { relatedTarget: this._element }; this._completeHide(h) } dispose() { this._popper && this._popper.destroy(), super.dispose() } update() { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update() } _completeHide(h) { E.default.trigger(this._element, A, h).defaultPrevented || ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(_t => E.default.off(_t, "mouseover", _)), this._popper && this._popper.destroy(), this._menu.classList.remove(w), this._element.classList.remove(w), this._element.setAttribute("aria-expanded", "false"), S.default.removeDataAttribute(this._menu, "popper"), E.default.trigger(this._element, Q, h)) } _getConfig(h) { if (h = { ...this.constructor.Default, ...S.default.getDataAttributes(this._element), ...h }, b(F, h, this.constructor.DefaultType), typeof h.reference == "object" && !T(h.reference) && typeof h.reference.getBoundingClientRect != "function") throw new TypeError(`${F.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`); return h } _createPopper(h) { if (typeof s == "undefined") throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); let U = this._element; this._config.reference === "parent" ? U = h : T(this._config.reference) ? U = O(this._config.reference) : typeof this._config.reference == "object" && (U = this._config.reference); let _t = this._getPopperConfig(), Ct = _t.modifiers.find(ht => ht.name === "applyStyles" && ht.enabled === !1); this._popper = s.createPopper(U, this._menu, _t), Ct && S.default.setDataAttribute(this._menu, "popper", "static") } _isShown(h = this._element) { return h.classList.contains(w) } _getMenuElement() { return v.default.next(this._element, Ot)[0] } _getPlacement() { let h = this._element.parentNode; if (h.classList.contains(K)) return u; if (h.classList.contains(ft)) return ut; let U = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end"; return h.classList.contains(L) ? U ? Pt : Dt : U ? a : R } _detectNavbar() { return this._element.closest(`.${St}`) !== null } _getOffset() { let { offset: h } = this._config; return typeof h == "string" ? h.split(",").map(U => Number.parseInt(U, 10)) : typeof h == "function" ? U => h(U, this._element) : h } _getPopperConfig() { let h = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] }; return this._config.display === "static" && (h.modifiers = [{ name: "applyStyles", enabled: !1 }]), { ...h, ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(h) : this._config.popperConfig } } _selectMenuItem({ key: h, target: U }) { let _t = v.default.find(vt, this._menu).filter(D); !_t.length || P(_t, U, h === Z, !_t.includes(U)).focus() } static jQueryInterface(h) { return this.each(function () { let U = bt.getOrCreateInstance(this, h); if (typeof h == "string") { if (typeof U[h] == "undefined") throw new TypeError(`No method named "${h}"`); U[h]() } }) } static clearMenus(h) { if (h && (h.button === B || h.type === "keyup" && h.key !== pt)) return; let U = v.default.find(yt); for (let _t = 0, Ct = U.length; _t < Ct; _t++) { let ht = bt.getInstance(U[_t]); if (!ht || ht._config.autoClose === !1 || !ht._isShown()) continue; let N = { relatedTarget: ht._element }; if (h) { let d = h.composedPath(), $ = d.includes(ht._menu); if (d.includes(ht._element) || ht._config.autoClose === "inside" && !$ || ht._config.autoClose === "outside" && $ || ht._menu.contains(h.target) && (h.type === "keyup" && h.key === pt || /input|select|option|textarea|form/i.test(h.target.tagName))) continue; h.type === "click" && (N.clickEvent = h) } ht._completeHide(N) } } static getParentFromElement(h) { return X(h) || h.parentNode } static dataApiKeydownHandler(h) { if (/input|textarea/i.test(h.target.tagName) ? h.key === nt || h.key !== ct && (h.key !== Z && h.key !== Et || h.target.closest(Ot)) : !p.test(h.key)) return; let U = this.classList.contains(w); if (!U && h.key === ct || (h.preventDefault(), h.stopPropagation(), q(this))) return; let _t = this.matches(yt) ? this : v.default.prev(this, yt)[0], Ct = bt.getOrCreateInstance(_t); if (h.key === ct) { Ct.hide(); return } if (h.key === Et || h.key === Z) { U || Ct.show(), Ct._selectMenuItem(h); return } (!U || h.key === nt) && bt.clearMenus() } } return E.default.on(document, z, yt, bt.dataApiKeydownHandler), E.default.on(document, z, Ot, bt.dataApiKeydownHandler), E.default.on(document, M, bt.clearMenus), E.default.on(document, mt, bt.clearMenus), E.default.on(document, M, yt, function (x) { x.preventDefault(), bt.getOrCreateInstance(this).toggle() }), j(bt), bt }) }); var yr = Ht((fi, di) => { (function (t, e) { typeof fi == "object" && typeof di != "undefined" ? di.exports = e(Ut(), ne(), ie(), Qt()) : typeof define == "function" && define.amd ? define(["./dom/event-handler", "./dom/manipulator", "./dom/selector-engine", "./base-component"], e) : (t = typeof globalThis != "undefined" ? globalThis : t || self, t.Modal = e(t.EventHandler, t.Manipulator, t.SelectorEngine, t.Base)) })(fi, function (t, e, n, o) { "use strict"; let r = C => C && typeof C == "object" && "default" in C ? C : { default: C }, i = r(t), c = r(e), s = r(n), E = r(o), S = 1e3, v = "transitionend", J = C => C == null ? `${C}` : {}.toString.call(C).match(/\s([a-z]+)/i)[1].toLowerCase(), tt = C => { let f = C.getAttribute("data-bs-target"); if (!f || f === "#") { let V = C.getAttribute("href"); if (!V || !V.includes("#") && !V.startsWith(".")) return null; V.includes("#") && !V.startsWith("#") && (V = `#${V.split("#")[1]}`), f = V && V !== "#" ? V.trim() : null } return f }, Y = C => { let f = tt(C); return f ? document.querySelector(f) : null }, X = C => { if (!C) return 0; let { transitionDuration: f, transitionDelay: V } = window.getComputedStyle(C), at = Number.parseFloat(f), At = Number.parseFloat(V); return !at && !At ? 0 : (f = f.split(",")[0], V = V.split(",")[0], (Number.parseFloat(f) + Number.parseFloat(V)) * S) }, T = C => { C.dispatchEvent(new Event(v)) }, O = C => !C || typeof C != "object" ? !1 : (typeof C.jquery != "undefined" && (C = C[0]), typeof C.nodeType != "undefined"), b = C => O(C) ? C.jquery ? C[0] : C : typeof C == "string" && C.length > 0 ? document.querySelector(C) : null, D = (C, f, V) => { Object.keys(V).forEach(at => { let At = V[at], It = f[at], qt = It && O(It) ? "element" : J(It); if (!new RegExp(At).test(qt)) throw new TypeError(`${C.toUpperCase()}: Option "${at}" provided type "${qt}" but expected type "${At}".`) }) }, q = C => !O(C) || C.getClientRects().length === 0 ? !1 : getComputedStyle(C).getPropertyValue("visibility") === "visible", _ = C => !C || C.nodeType !== Node.ELEMENT_NODE || C.classList.contains("disabled") ? !0 : typeof C.disabled != "undefined" ? C.disabled : C.hasAttribute("disabled") && C.getAttribute("disabled") !== "false", l = C => { C.offsetHeight }, g = () => { let { jQuery: C } = window; return C && !document.body.hasAttribute("data-bs-no-jquery") ? C : null }, y = [], W = C => { document.readyState === "loading" ? (y.length || document.addEventListener("DOMContentLoaded", () => { y.forEach(f => f()) }), y.push(C)) : C() }, j = () => document.documentElement.dir === "rtl", P = C => { W(() => { let f = g(); if (f) { let V = C.NAME, at = f.fn[V]; f.fn[V] = C.jQueryInterface, f.fn[V].Constructor = C, f.fn[V].noConflict = () => (f.fn[V] = at, C.jQueryInterface) } }) }, F = C => { typeof C == "function" && C() }, st = (C, f, V = !0) => { if (!V) { F(C); return } let at = 5, At = X(f) + at, It = !1, qt = ({ target: qe }) => { qe === f && (It = !0, f.removeEventListener(v, qt), F(C)) }; f.addEventListener(v, qt), setTimeout(() => { It || T(f) }, At) }, et = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", gt = ".sticky-top"; class ct { constructor() { this._element = document.body } getWidth() { let f = document.documentElement.clientWidth; return Math.abs(window.innerWidth - f) } hide() { let f = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, "paddingRight", V => V + f), this._setElementAttributes(et, "paddingRight", V => V + f), this._setElementAttributes(gt, "marginRight", V => V - f) } _disableOverFlow() { this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden" } _setElementAttributes(f, V, at) { let At = this.getWidth(), It = qt => { if (qt !== this._element && window.innerWidth > qt.clientWidth + At) return; this._saveInitialAttribute(qt, V); let qe = window.getComputedStyle(qt)[V]; qt.style[V] = `${at(Number.parseFloat(qe))}px` }; this._applyManipulationCallback(f, It) } reset() { this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes(et, "paddingRight"), this._resetElementAttributes(gt, "marginRight") } _saveInitialAttribute(f, V) { let at = f.style[V]; at && c.default.setDataAttribute(f, V, at) } _resetElementAttributes(f, V) { let at = At => { let It = c.default.getDataAttribute(At, V); typeof It == "undefined" ? At.style.removeProperty(V) : (c.default.removeDataAttribute(At, V), At.style[V] = It) }; this._applyManipulationCallback(f, at) } _applyManipulationCallback(f, V) { O(f) ? V(f) : s.default.find(f, this._element).forEach(V) } isOverflowing() { return this.getWidth() > 0 } } let nt = { className: "modal-backdrop", isVisible: !0, isAnimated: !1, rootElement: "body", clickCallback: null }, pt = { className: "string", isVisible: "boolean", isAnimated: "boolean", rootElement: "(element|string)", clickCallback: "(function|null)" }, Et = "backdrop", Z = "fade", B = "show", p = `mousedown.bs.${Et}`; class A { constructor(f) { this._config = this._getConfig(f), this._isAppended = !1, this._element = null } show(f) { if (!this._config.isVisible) { F(f); return } this._append(), this._config.isAnimated && l(this._getElement()), this._getElement().classList.add(B), this._emulateAnimation(() => { F(f) }) } hide(f) { if (!this._config.isVisible) { F(f); return } this._getElement().classList.remove(B), this._emulateAnimation(() => { this.dispose(), F(f) }) } _getElement() { if (!this._element) { let f = document.createElement("div"); f.className = this._config.className, this._config.isAnimated && f.classList.add(Z), this._element = f } return this._element } _getConfig(f) { return f = { ...nt, ...typeof f == "object" ? f : {} }, f.rootElement = b(f.rootElement), D(Et, f, pt), f } _append() { this._isAppended || (this._config.rootElement.append(this._getElement()), i.default.on(this._getElement(), p, () => { F(this._config.clickCallback) }), this._isAppended = !0) } dispose() { !this._isAppended || (i.default.off(this._element, p), this._element.remove(), this._isAppended = !1) } _emulateAnimation(f) { st(f, this._getElement(), this._config.isAnimated) } } let Q = { trapElement: null, autofocus: !0 }, rt = { trapElement: "element", autofocus: "boolean" }, k = "focustrap", z = ".bs.focustrap", mt = `focusin${z}`, w = `keydown.tab${z}`, L = "Tab", K = "forward", ft = "backward"; class St { constructor(f) { this._config = this._getConfig(f), this._isActive = !1, this._lastTabNavDirection = null } activate() { let { trapElement: f, autofocus: V } = this._config; this._isActive || (V && f.focus(), i.default.off(document, z), i.default.on(document, mt, at => this._handleFocusin(at)), i.default.on(document, w, at => this._handleKeydown(at)), this._isActive = !0) } deactivate() { !this._isActive || (this._isActive = !1, i.default.off(document, z)) } _handleFocusin(f) { let { target: V } = f, { trapElement: at } = this._config; if (V === document || V === at || at.contains(V)) return; let At = s.default.focusableChildren(at); At.length === 0 ? at.focus() : this._lastTabNavDirection === ft ? At[At.length - 1].focus() : At[0].focus() } _handleKeydown(f) { f.key === L && (this._lastTabNavDirection = f.shiftKey ? ft : K) } _getConfig(f) { return f = { ...Q, ...typeof f == "object" ? f : {} }, D(k, f, rt), f } } let yt = (C, f = "hide") => { let V = `click.dismiss${C.EVENT_KEY}`, at = C.NAME; i.default.on(document, V, `[data-bs-dismiss="${at}"]`, function (At) { if (["A", "AREA"].includes(this.tagName) && At.preventDefault(), _(this)) return; let It = Y(this) || this.closest(`.${at}`); C.getOrCreateInstance(It)[f]() }) }, Ot = "modal", vt = ".bs.modal", Dt = ".data-api", Pt = "Escape", R = { backdrop: !0, keyboard: !0, focus: !0 }, a = { backdrop: "(boolean|string)", keyboard: "boolean", focus: "boolean" }, u = `hide${vt}`, ut = `hidePrevented${vt}`, lt = `hidden${vt}`, Tt = `show${vt}`, bt = `shown${vt}`, x = `resize${vt}`, h = `click.dismiss${vt}`, U = `keydown.dismiss${vt}`, _t = `mouseup.dismiss${vt}`, Ct = `mousedown.dismiss${vt}`, ht = `click${vt}${Dt}`, N = "modal-open", d = "fade", $ = "show", I = "modal-static", m = ".modal.show", H = ".modal-dialog", it = ".modal-body", dt = '[data-bs-toggle="modal"]'; class ot extends E.default { constructor(f, V) { super(f); this._config = this._getConfig(V), this._dialog = s.default.findOne(H, this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new ct } static get Default() { return R } static get NAME() { return Ot } toggle(f) { return this._isShown ? this.hide() : this.show(f) } show(f) { this._isShown || this._isTransitioning || i.default.trigger(this._element, Tt, { relatedTarget: f }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), this._scrollBar.hide(), document.body.classList.add(N), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), i.default.on(this._dialog, Ct, () => { i.default.one(this._element, _t, at => { at.target === this._element && (this._ignoreBackdropClick = !0) }) }), this._showBackdrop(() => this._showElement(f))) } hide() { if (!this._isShown || this._isTransitioning || i.default.trigger(this._element, u).defaultPrevented) return; this._isShown = !1; let V = this._isAnimated(); V && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.deactivate(), this._element.classList.remove($), i.default.off(this._element, h), i.default.off(this._dialog, Ct), this._queueCallback(() => this._hideModal(), this._element, V) } dispose() { [window, this._dialog].forEach(f => i.default.off(f, vt)), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } handleUpdate() { this._adjustDialog() } _initializeBackDrop() { return new A({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() }) } _initializeFocusTrap() { return new St({ trapElement: this._element }) } _getConfig(f) { return f = { ...R, ...c.default.getDataAttributes(this._element), ...typeof f == "object" ? f : {} }, D(Ot, f, a), f } _showElement(f) { let V = this._isAnimated(), at = s.default.findOne(it, this._dialog); (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) && document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0, at && (at.scrollTop = 0), V && l(this._element), this._element.classList.add($); let At = () => { this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, i.default.trigger(this._element, bt, { relatedTarget: f }) }; this._queueCallback(At, this._dialog, V) } _setEscapeEvent() { this._isShown ? i.default.on(this._element, U, f => { this._config.keyboard && f.key === Pt ? (f.preventDefault(), this.hide()) : !this._config.keyboard && f.key === Pt && this._triggerBackdropTransition() }) : i.default.off(this._element, U) } _setResizeEvent() { this._isShown ? i.default.on(window, x, () => this._adjustDialog()) : i.default.off(window, x) } _hideModal() { this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => { document.body.classList.remove(N), this._resetAdjustments(), this._scrollBar.reset(), i.default.trigger(this._element, lt) }) } _showBackdrop(f) { i.default.on(this._element, h, V => { if (this._ignoreBackdropClick) { this._ignoreBackdropClick = !1; return } V.target === V.currentTarget && (this._config.backdrop === !0 ? this.hide() : this._config.backdrop === "static" && this._triggerBackdropTransition()) }), this._backdrop.show(f) } _isAnimated() { return this._element.classList.contains(d) } _triggerBackdropTransition() { if (i.default.trigger(this._element, ut).defaultPrevented) return; let { classList: V, scrollHeight: at, style: At } = this._element, It = at > document.documentElement.clientHeight; !It && At.overflowY === "hidden" || V.contains(I) || (It || (At.overflowY = "hidden"), V.add(I), this._queueCallback(() => { V.remove(I), It || this._queueCallback(() => { At.overflowY = "" }, this._dialog) }, this._dialog), this._element.focus()) } _adjustDialog() { let f = this._element.scrollHeight > document.documentElement.clientHeight, V = this._scrollBar.getWidth(), at = V > 0; (!at && f && !j() || at && !f && j()) && (this._element.style.paddingLeft = `${V}px`), (at && !f && !j() || !at && f && j()) && (this._element.style.paddingRight = `${V}px`) } _resetAdjustments() { this._element.style.paddingLeft = "", this._element.style.paddingRight = "" } static jQueryInterface(f, V) { return this.each(function () { let at = ot.getOrCreateInstance(this, f); if (typeof f == "string") { if (typeof at[f] == "undefined") throw new TypeError(`No method named "${f}"`); at[f](V) } }) } } return i.default.on(document, ht, dt, function (C) { let f = Y(this);["A", "AREA"].includes(this.tagName) && C.preventDefault(), i.default.one(f, Tt, At => { At.defaultPrevented || i.default.one(f, lt, () => { q(this) && this.focus() }) }); let V = s.default.findOne(m); V && ot.getInstance(V).hide(), ot.getOrCreateInstance(f).toggle(this) }), yt(ot), P(ot), ot }) }); var Ar = Ht((pi, hi) => { (function (t, e) { typeof pi == "object" && typeof hi != "undefined" ? hi.exports = e(ie(), ne(), Ut(), Qt()) : typeof define == "function" && define.amd ? define(["./dom/selector-engine", "./dom/manipulator", "./dom/event-handler", "./base-component"], e) : (t = typeof globalThis != "undefined" ? globalThis : t || self, t.Offcanvas = e(t.SelectorEngine, t.Manipulator, t.EventHandler, t.Base)) })(pi, function (t, e, n, o) { "use strict"; let r = N => N && typeof N == "object" && "default" in N ? N : { default: N }, i = r(t), c = r(e), s = r(n), E = r(o), S = 1e3, v = "transitionend", J = N => N == null ? `${N}` : {}.toString.call(N).match(/\s([a-z]+)/i)[1].toLowerCase(), tt = N => { let d = N.getAttribute("data-bs-target"); if (!d || d === "#") { let $ = N.getAttribute("href"); if (!$ || !$.includes("#") && !$.startsWith(".")) return null; $.includes("#") && !$.startsWith("#") && ($ = `#${$.split("#")[1]}`), d = $ && $ !== "#" ? $.trim() : null } return d }, Y = N => { let d = tt(N); return d ? document.querySelector(d) : null }, X = N => { if (!N) return 0; let { transitionDuration: d, transitionDelay: $ } = window.getComputedStyle(N), I = Number.parseFloat(d), m = Number.parseFloat($); return !I && !m ? 0 : (d = d.split(",")[0], $ = $.split(",")[0], (Number.parseFloat(d) + Number.parseFloat($)) * S) }, T = N => { N.dispatchEvent(new Event(v)) }, O = N => !N || typeof N != "object" ? !1 : (typeof N.jquery != "undefined" && (N = N[0]), typeof N.nodeType != "undefined"), b = N => O(N) ? N.jquery ? N[0] : N : typeof N == "string" && N.length > 0 ? document.querySelector(N) : null, D = (N, d, $) => { Object.keys($).forEach(I => { let m = $[I], H = d[I], it = H && O(H) ? "element" : J(H); if (!new RegExp(m).test(it)) throw new TypeError(`${N.toUpperCase()}: Option "${I}" provided type "${it}" but expected type "${m}".`) }) }, q = N => !O(N) || N.getClientRects().length === 0 ? !1 : getComputedStyle(N).getPropertyValue("visibility") === "visible", _ = N => !N || N.nodeType !== Node.ELEMENT_NODE || N.classList.contains("disabled") ? !0 : typeof N.disabled != "undefined" ? N.disabled : N.hasAttribute("disabled") && N.getAttribute("disabled") !== "false", l = N => { N.offsetHeight }, g = () => { let { jQuery: N } = window; return N && !document.body.hasAttribute("data-bs-no-jquery") ? N : null }, y = [], W = N => { document.readyState === "loading" ? (y.length || document.addEventListener("DOMContentLoaded", () => { y.forEach(d => d()) }), y.push(N)) : N() }, j = N => { W(() => { let d = g(); if (d) { let $ = N.NAME, I = d.fn[$]; d.fn[$] = N.jQueryInterface, d.fn[$].Constructor = N, d.fn[$].noConflict = () => (d.fn[$] = I, N.jQueryInterface) } }) }, P = N => { typeof N == "function" && N() }, F = (N, d, $ = !0) => { if (!$) { P(N); return } let I = 5, m = X(d) + I, H = !1, it = ({ target: dt }) => { dt === d && (H = !0, d.removeEventListener(v, it), P(N)) }; d.addEventListener(v, it), setTimeout(() => { H || T(d) }, m) }, st = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", et = ".sticky-top"; class gt { constructor() { this._element = document.body } getWidth() { let d = document.documentElement.clientWidth; return Math.abs(window.innerWidth - d) } hide() { let d = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, "paddingRight", $ => $ + d), this._setElementAttributes(st, "paddingRight", $ => $ + d), this._setElementAttributes(et, "marginRight", $ => $ - d) } _disableOverFlow() { this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden" } _setElementAttributes(d, $, I) { let m = this.getWidth(), H = it => { if (it !== this._element && window.innerWidth > it.clientWidth + m) return; this._saveInitialAttribute(it, $); let dt = window.getComputedStyle(it)[$]; it.style[$] = `${I(Number.parseFloat(dt))}px` }; this._applyManipulationCallback(d, H) } reset() { this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes(st, "paddingRight"), this._resetElementAttributes(et, "marginRight") } _saveInitialAttribute(d, $) { let I = d.style[$]; I && c.default.setDataAttribute(d, $, I) } _resetElementAttributes(d, $) { let I = m => { let H = c.default.getDataAttribute(m, $); typeof H == "undefined" ? m.style.removeProperty($) : (c.default.removeDataAttribute(m, $), m.style[$] = H) }; this._applyManipulationCallback(d, I) } _applyManipulationCallback(d, $) { O(d) ? $(d) : i.default.find(d, this._element).forEach($) } isOverflowing() { return this.getWidth() > 0 } } let ct = { className: "modal-backdrop", isVisible: !0, isAnimated: !1, rootElement: "body", clickCallback: null }, nt = { className: "string", isVisible: "boolean", isAnimated: "boolean", rootElement: "(element|string)", clickCallback: "(function|null)" }, pt = "backdrop", Et = "fade", Z = "show", B = `mousedown.bs.${pt}`; class p { constructor(d) { this._config = this._getConfig(d), this._isAppended = !1, this._element = null } show(d) { if (!this._config.isVisible) { P(d); return } this._append(), this._config.isAnimated && l(this._getElement()), this._getElement().classList.add(Z), this._emulateAnimation(() => { P(d) }) } hide(d) { if (!this._config.isVisible) { P(d); return } this._getElement().classList.remove(Z), this._emulateAnimation(() => { this.dispose(), P(d) }) } _getElement() { if (!this._element) { let d = document.createElement("div"); d.className = this._config.className, this._config.isAnimated && d.classList.add(Et), this._element = d } return this._element } _getConfig(d) { return d = { ...ct, ...typeof d == "object" ? d : {} }, d.rootElement = b(d.rootElement), D(pt, d, nt), d } _append() { this._isAppended || (this._config.rootElement.append(this._getElement()), s.default.on(this._getElement(), B, () => { P(this._config.clickCallback) }), this._isAppended = !0) } dispose() { !this._isAppended || (s.default.off(this._element, B), this._element.remove(), this._isAppended = !1) } _emulateAnimation(d) { F(d, this._getElement(), this._config.isAnimated) } } let A = { trapElement: null, autofocus: !0 }, Q = { trapElement: "element", autofocus: "boolean" }, rt = "focustrap", M = ".bs.focustrap", z = `focusin${M}`, mt = `keydown.tab${M}`, w = "Tab", L = "forward", K = "backward"; class ft { constructor(d) { this._config = this._getConfig(d), this._isActive = !1, this._lastTabNavDirection = null } activate() { let { trapElement: d, autofocus: $ } = this._config; this._isActive || ($ && d.focus(), s.default.off(document, M), s.default.on(document, z, I => this._handleFocusin(I)), s.default.on(document, mt, I => this._handleKeydown(I)), this._isActive = !0) } deactivate() { !this._isActive || (this._isActive = !1, s.default.off(document, M)) } _handleFocusin(d) { let { target: $ } = d, { trapElement: I } = this._config; if ($ === document || $ === I || I.contains($)) return; let m = i.default.focusableChildren(I); m.length === 0 ? I.focus() : this._lastTabNavDirection === K ? m[m.length - 1].focus() : m[0].focus() } _handleKeydown(d) { d.key === w && (this._lastTabNavDirection = d.shiftKey ? K : L) } _getConfig(d) { return d = { ...A, ...typeof d == "object" ? d : {} }, D(rt, d, Q), d } } let St = (N, d = "hide") => { let $ = `click.dismiss${N.EVENT_KEY}`, I = N.NAME; s.default.on(document, $, `[data-bs-dismiss="${I}"]`, function (m) { if (["A", "AREA"].includes(this.tagName) && m.preventDefault(), _(this)) return; let H = Y(this) || this.closest(`.${I}`); N.getOrCreateInstance(H)[d]() }) }, yt = "offcanvas", wt = ".bs.offcanvas", vt = ".data-api", Dt = `load${wt}${vt}`, Pt = "Escape", R = { backdrop: !0, keyboard: !0, scroll: !1 }, a = { backdrop: "boolean", keyboard: "boolean", scroll: "boolean" }, u = "show", ut = "offcanvas-backdrop", lt = ".offcanvas.show", Tt = `show${wt}`, bt = `shown${wt}`, x = `hide${wt}`, h = `hidden${wt}`, U = `click${wt}${vt}`, _t = `keydown.dismiss${wt}`, Ct = '[data-bs-toggle="offcanvas"]'; class ht extends E.default { constructor(d, $) { super(d); this._config = this._getConfig($), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners() } static get NAME() { return yt } static get Default() { return R } toggle(d) { return this._isShown ? this.hide() : this.show(d) } show(d) { if (this._isShown || s.default.trigger(this._element, Tt, { relatedTarget: d }).defaultPrevented) return; this._isShown = !0, this._element.style.visibility = "visible", this._backdrop.show(), this._config.scroll || new gt().hide(), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(u); let I = () => { this._config.scroll || this._focustrap.activate(), s.default.trigger(this._element, bt, { relatedTarget: d }) }; this._queueCallback(I, this._element, !0) } hide() { if (!this._isShown || s.default.trigger(this._element, x).defaultPrevented) return; this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.remove(u), this._backdrop.hide(); let $ = () => { this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._element.style.visibility = "hidden", this._config.scroll || new gt().reset(), s.default.trigger(this._element, h) }; this._queueCallback($, this._element, !0) } dispose() { this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } _getConfig(d) { return d = { ...R, ...c.default.getDataAttributes(this._element), ...typeof d == "object" ? d : {} }, D(yt, d, a), d } _initializeBackDrop() { return new p({ className: ut, isVisible: this._config.backdrop, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: () => this.hide() }) } _initializeFocusTrap() { return new ft({ trapElement: this._element }) } _addEventListeners() { s.default.on(this._element, _t, d => { this._config.keyboard && d.key === Pt && this.hide() }) } static jQueryInterface(d) { return this.each(function () { let $ = ht.getOrCreateInstance(this, d); if (typeof d == "string") { if ($[d] === void 0 || d.startsWith("_") || d === "constructor") throw new TypeError(`No method named "${d}"`); $[d](this) } }) } } return s.default.on(document, U, Ct, function (N) { let d = Y(this); if (["A", "AREA"].includes(this.tagName) && N.preventDefault(), _(this)) return; s.default.one(d, h, () => { q(this) && this.focus() }); let $ = i.default.findOne(lt); $ && $ !== d && ht.getInstance($).hide(), ht.getOrCreateInstance(d).toggle(this) }), s.default.on(window, Dt, () => i.default.find(lt).forEach(N => ht.getOrCreateInstance(N).show())), St(ht), j(ht), ht }) }); var gi = Ht((mi, _i) => { (function (t, e) { typeof mi == "object" && typeof _i != "undefined" ? _i.exports = e((li(), Di(ai)), Fe(), Ut(), ne(), ie(), Qt()) : typeof define == "function" && define.amd ? define(["@popperjs/core", "./dom/data", "./dom/event-handler", "./dom/manipulator", "./dom/selector-engine", "./base-component"], e) : (t = typeof globalThis != "undefined" ? globalThis : t || self, t.Tooltip = e(t.Popper, t.Data, t.EventHandler, t.Manipulator, t.SelectorEngine, t.Base)) })(mi, function (t, e, n, o, r, i) { "use strict"; let c = R => R && typeof R == "object" && "default" in R ? R : { default: R }; function s(R) { if (R && R.__esModule) return R; let a = Object.create(null); if (R) { for (let u in R) if (u !== "default") { let ut = Object.getOwnPropertyDescriptor(R, u); Object.defineProperty(a, u, ut.get ? ut : { enumerable: !0, get: () => R[u] }) } } return a.default = R, Object.freeze(a) } let E = s(t), S = c(e), v = c(n), J = c(o), tt = c(r), Y = c(i), X = 1e6, T = R => R == null ? `${R}` : {}.toString.call(R).match(/\s([a-z]+)/i)[1].toLowerCase(), O = R => { do R += Math.floor(Math.random() * X); while (document.getElementById(R)); return R }, b = R => !R || typeof R != "object" ? !1 : (typeof R.jquery != "undefined" && (R = R[0]), typeof R.nodeType != "undefined"), D = R => b(R) ? R.jquery ? R[0] : R : typeof R == "string" && R.length > 0 ? document.querySelector(R) : null, q = (R, a, u) => { Object.keys(u).forEach(ut => { let lt = u[ut], Tt = a[ut], bt = Tt && b(Tt) ? "element" : T(Tt); if (!new RegExp(lt).test(bt)) throw new TypeError(`${R.toUpperCase()}: Option "${ut}" provided type "${bt}" but expected type "${lt}".`) }) }, _ = R => { if (!document.documentElement.attachShadow) return null; if (typeof R.getRootNode == "function") { let a = R.getRootNode(); return a instanceof ShadowRoot ? a : null } return R instanceof ShadowRoot ? R : R.parentNode ? _(R.parentNode) : null }, l = () => { }, g = () => { let { jQuery: R } = window; return R && !document.body.hasAttribute("data-bs-no-jquery") ? R : null }, y = [], W = R => { document.readyState === "loading" ? (y.length || document.addEventListener("DOMContentLoaded", () => { y.forEach(a => a()) }), y.push(R)) : R() }, j = () => document.documentElement.dir === "rtl", P = R => { W(() => { let a = g(); if (a) { let u = R.NAME, ut = a.fn[u]; a.fn[u] = R.jQueryInterface, a.fn[u].Constructor = R, a.fn[u].noConflict = () => (a.fn[u] = ut, R.jQueryInterface) } }) }, F = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), st = /^aria-[\w-]*$/i, et = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, gt = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, ct = (R, a) => { let u = R.nodeName.toLowerCase(); if (a.includes(u)) return F.has(u) ? Boolean(et.test(R.nodeValue) || gt.test(R.nodeValue)) : !0; let ut = a.filter(lt => lt instanceof RegExp); for (let lt = 0, Tt = ut.length; lt < Tt; lt++)if (ut[lt].test(u)) return !0; return !1 }, nt = { "*": ["class", "dir", "id", "lang", "role", st], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }; function pt(R, a, u) { if (!R.length) return R; if (u && typeof u == "function") return u(R); let lt = new window.DOMParser().parseFromString(R, "text/html"), Tt = [].concat(...lt.body.querySelectorAll("*")); for (let bt = 0, x = Tt.length; bt < x; bt++) { let h = Tt[bt], U = h.nodeName.toLowerCase(); if (!Object.keys(a).includes(U)) { h.remove(); continue } let _t = [].concat(...h.attributes), Ct = [].concat(a["*"] || [], a[U] || []); _t.forEach(ht => { ct(ht, Ct) || h.removeAttribute(ht.nodeName) }) } return lt.body.innerHTML } let Et = "tooltip", B = ".bs.tooltip", p = "bs-tooltip", A = new Set(["sanitize", "allowList", "sanitizeFn"]), Q = { animation: "boolean", template: "string", title: "(string|element|function)", trigger: "string", delay: "(number|object)", html: "boolean", selector: "(string|boolean)", placement: "(string|function)", offset: "(array|string|function)", container: "(string|element|boolean)", fallbackPlacements: "array", boundary: "(string|element)", customClass: "(string|function)", sanitize: "boolean", sanitizeFn: "(null|function)", allowList: "object", popperConfig: "(null|object|function)" }, rt = { AUTO: "auto", TOP: "top", RIGHT: j() ? "left" : "right", BOTTOM: "bottom", LEFT: j() ? "right" : "left" }, k = { animation: !0, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', trigger: "hover focus", title: "", delay: 0, html: !1, selector: !1, placement: "top", offset: [0, 0], container: !1, fallbackPlacements: ["top", "right", "bottom", "left"], boundary: "clippingParents", customClass: "", sanitize: !0, sanitizeFn: null, allowList: nt, popperConfig: null }, M = { HIDE: `hide${B}`, HIDDEN: `hidden${B}`, SHOW: `show${B}`, SHOWN: `shown${B}`, INSERTED: `inserted${B}`, CLICK: `click${B}`, FOCUSIN: `focusin${B}`, FOCUSOUT: `focusout${B}`, MOUSEENTER: `mouseenter${B}`, MOUSELEAVE: `mouseleave${B}` }, z = "fade", mt = "modal", w = "show", L = "show", K = "out", ft = ".tooltip-inner", St = `.${mt}`, yt = "hide.bs.modal", Ot = "hover", wt = "focus", vt = "click", Dt = "manual"; class Pt extends Y.default { constructor(a, u) { if (typeof E == "undefined") throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)"); super(a); this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(u), this.tip = null, this._setListeners() } static get Default() { return k } static get NAME() { return Et } static get Event() { return M } static get DefaultType() { return Q } enable() { this._isEnabled = !0 } disable() { this._isEnabled = !1 } toggleEnabled() { this._isEnabled = !this._isEnabled } toggle(a) { if (!!this._isEnabled) if (a) { let u = this._initializeOnDelegatedTarget(a); u._activeTrigger.click = !u._activeTrigger.click, u._isWithActiveTrigger() ? u._enter(null, u) : u._leave(null, u) } else { if (this.getTipElement().classList.contains(w)) { this._leave(null, this); return } this._enter(null, this) } } dispose() { clearTimeout(this._timeout), v.default.off(this._element.closest(St), yt, this._hideModalHandler), this.tip && this.tip.remove(), this._disposePopper(), super.dispose() } show() { if (this._element.style.display === "none") throw new Error("Please use show on visible elements"); if (!(this.isWithContent() && this._isEnabled)) return; let a = v.default.trigger(this._element, this.constructor.Event.SHOW), u = _(this._element), ut = u === null ? this._element.ownerDocument.documentElement.contains(this._element) : u.contains(this._element); if (a.defaultPrevented || !ut) return; this.constructor.NAME === "tooltip" && this.tip && this.getTitle() !== this.tip.querySelector(ft).innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null); let lt = this.getTipElement(), Tt = O(this.constructor.NAME); lt.setAttribute("id", Tt), this._element.setAttribute("aria-describedby", Tt), this._config.animation && lt.classList.add(z); let bt = typeof this._config.placement == "function" ? this._config.placement.call(this, lt, this._element) : this._config.placement, x = this._getAttachment(bt); this._addAttachmentClass(x); let { container: h } = this._config; S.default.set(lt, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (h.append(lt), v.default.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = E.createPopper(this._element, lt, this._getPopperConfig(x)), lt.classList.add(w); let U = this._resolvePossibleFunction(this._config.customClass); U && lt.classList.add(...U.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(ht => { v.default.on(ht, "mouseover", l) }); let _t = () => { let ht = this._hoverState; this._hoverState = null, v.default.trigger(this._element, this.constructor.Event.SHOWN), ht === K && this._leave(null, this) }, Ct = this.tip.classList.contains(z); this._queueCallback(_t, this.tip, Ct) } hide() { if (!this._popper) return; let a = this.getTipElement(), u = () => { this._isWithActiveTrigger() || (this._hoverState !== L && a.remove(), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), v.default.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper()) }; if (v.default.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) return; a.classList.remove(w), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(Tt => v.default.off(Tt, "mouseover", l)), this._activeTrigger[vt] = !1, this._activeTrigger[wt] = !1, this._activeTrigger[Ot] = !1; let lt = this.tip.classList.contains(z); this._queueCallback(u, this.tip, lt), this._hoverState = "" } update() { this._popper !== null && this._popper.update() } isWithContent() { return Boolean(this.getTitle()) } getTipElement() { if (this.tip) return this.tip; let a = document.createElement("div"); a.innerHTML = this._config.template; let u = a.children[0]; return this.setContent(u), u.classList.remove(z, w), this.tip = u, this.tip } setContent(a) { this._sanitizeAndSetContent(a, this.getTitle(), ft) } _sanitizeAndSetContent(a, u, ut) { let lt = tt.default.findOne(ut, a); if (!u && lt) { lt.remove(); return } this.setElementContent(lt, u) } setElementContent(a, u) { if (a !== null) { if (b(u)) { u = D(u), this._config.html ? u.parentNode !== a && (a.innerHTML = "", a.append(u)) : a.textContent = u.textContent; return } this._config.html ? (this._config.sanitize && (u = pt(u, this._config.allowList, this._config.sanitizeFn)), a.innerHTML = u) : a.textContent = u } } getTitle() { let a = this._element.getAttribute("data-bs-original-title") || this._config.title; return this._resolvePossibleFunction(a) } updateAttachment(a) { return a === "right" ? "end" : a === "left" ? "start" : a } _initializeOnDelegatedTarget(a, u) { return u || this.constructor.getOrCreateInstance(a.delegateTarget, this._getDelegateConfig()) } _getOffset() { let { offset: a } = this._config; return typeof a == "string" ? a.split(",").map(u => Number.parseInt(u, 10)) : typeof a == "function" ? u => a(u, this._element) : a } _resolvePossibleFunction(a) { return typeof a == "function" ? a.call(this._element) : a } _getPopperConfig(a) { let u = { placement: a, modifiers: [{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: "offset", options: { offset: this._getOffset() } }, { name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } }, { name: "onChange", enabled: !0, phase: "afterWrite", fn: ut => this._handlePopperPlacementChange(ut) }], onFirstUpdate: ut => { ut.options.placement !== ut.placement && this._handlePopperPlacementChange(ut) } }; return { ...u, ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(u) : this._config.popperConfig } } _addAttachmentClass(a) { this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(a)}`) } _getAttachment(a) { return rt[a.toUpperCase()] } _setListeners() { this._config.trigger.split(" ").forEach(u => { if (u === "click") v.default.on(this._element, this.constructor.Event.CLICK, this._config.selector, ut => this.toggle(ut)); else if (u !== Dt) { let ut = u === Ot ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, lt = u === Ot ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT; v.default.on(this._element, ut, this._config.selector, Tt => this._enter(Tt)), v.default.on(this._element, lt, this._config.selector, Tt => this._leave(Tt)) } }), this._hideModalHandler = () => { this._element && this.hide() }, v.default.on(this._element.closest(St), yt, this._hideModalHandler), this._config.selector ? this._config = { ...this._config, trigger: "manual", selector: "" } : this._fixTitle() } _fixTitle() { let a = this._element.getAttribute("title"), u = typeof this._element.getAttribute("data-bs-original-title"); (a || u !== "string") && (this._element.setAttribute("data-bs-original-title", a || ""), a && !this._element.getAttribute("aria-label") && !this._element.textContent && this._element.setAttribute("aria-label", a), this._element.setAttribute("title", "")) } _enter(a, u) { if (u = this._initializeOnDelegatedTarget(a, u), a && (u._activeTrigger[a.type === "focusin" ? wt : Ot] = !0), u.getTipElement().classList.contains(w) || u._hoverState === L) { u._hoverState = L; return } if (clearTimeout(u._timeout), u._hoverState = L, !u._config.delay || !u._config.delay.show) { u.show(); return } u._timeout = setTimeout(() => { u._hoverState === L && u.show() }, u._config.delay.show) } _leave(a, u) { if (u = this._initializeOnDelegatedTarget(a, u), a && (u._activeTrigger[a.type === "focusout" ? wt : Ot] = u._element.contains(a.relatedTarget)), !u._isWithActiveTrigger()) { if (clearTimeout(u._timeout), u._hoverState = K, !u._config.delay || !u._config.delay.hide) { u.hide(); return } u._timeout = setTimeout(() => { u._hoverState === K && u.hide() }, u._config.delay.hide) } } _isWithActiveTrigger() { for (let a in this._activeTrigger) if (this._activeTrigger[a]) return !0; return !1 } _getConfig(a) { let u = J.default.getDataAttributes(this._element); return Object.keys(u).forEach(ut => { A.has(ut) && delete u[ut] }), a = { ...this.constructor.Default, ...u, ...typeof a == "object" && a ? a : {} }, a.container = a.container === !1 ? document.body : D(a.container), typeof a.delay == "number" && (a.delay = { show: a.delay, hide: a.delay }), typeof a.title == "number" && (a.title = a.title.toString()), typeof a.content == "number" && (a.content = a.content.toString()), q(Et, a, this.constructor.DefaultType), a.sanitize && (a.template = pt(a.template, a.allowList, a.sanitizeFn)), a } _getDelegateConfig() { let a = {}; for (let u in this._config) this.constructor.Default[u] !== this._config[u] && (a[u] = this._config[u]); return a } _cleanTipClass() { let a = this.getTipElement(), u = new RegExp(`(^|\\s)${this._getBasicClassPrefix()}\\S+`, "g"), ut = a.getAttribute("class").match(u); ut !== null && ut.length > 0 && ut.map(lt => lt.trim()).forEach(lt => a.classList.remove(lt)) } _getBasicClassPrefix() { return p } _handlePopperPlacementChange(a) { let { state: u } = a; !u || (this.tip = u.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(u.placement))) } _disposePopper() { this._popper && (this._popper.destroy(), this._popper = null) } static jQueryInterface(a) { return this.each(function () { let u = Pt.getOrCreateInstance(this, a); if (typeof a == "string") { if (typeof u[a] == "undefined") throw new TypeError(`No method named "${a}"`); u[a]() } }) } } return P(Pt), Pt }) }); var Tr = Ht((Ei, vi) => { (function (t, e) { typeof Ei == "object" && typeof vi != "undefined" ? vi.exports = e(gi()) : typeof define == "function" && define.amd ? define(["./tooltip"], e) : (t = typeof globalThis != "undefined" ? globalThis : t || self, t.Popover = e(t.Tooltip)) })(Ei, function (t) { "use strict"; let n = (b => b && typeof b == "object" && "default" in b ? b : { default: b })(t), o = () => { let { jQuery: b } = window; return b && !document.body.hasAttribute("data-bs-no-jquery") ? b : null }, r = [], i = b => { document.readyState === "loading" ? (r.length || document.addEventListener("DOMContentLoaded", () => { r.forEach(D => D()) }), r.push(b)) : b() }, c = b => { i(() => { let D = o(); if (D) { let q = b.NAME, _ = D.fn[q]; D.fn[q] = b.jQueryInterface, D.fn[q].Constructor = b, D.fn[q].noConflict = () => (D.fn[q] = _, b.jQueryInterface) } }) }, s = "popover", S = ".bs.popover", v = "bs-popover", J = { ...n.default.Default, placement: "right", offset: [0, 8], trigger: "click", content: "", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>' }, tt = { ...n.default.DefaultType, content: "(string|element|function)" }, Y = { HIDE: `hide${S}`, HIDDEN: `hidden${S}`, SHOW: `show${S}`, SHOWN: `shown${S}`, INSERTED: `inserted${S}`, CLICK: `click${S}`, FOCUSIN: `focusin${S}`, FOCUSOUT: `focusout${S}`, MOUSEENTER: `mouseenter${S}`, MOUSELEAVE: `mouseleave${S}` }, X = ".popover-header", T = ".popover-body"; class O extends n.default { static get Default() { return J } static get NAME() { return s } static get Event() { return Y } static get DefaultType() { return tt } isWithContent() { return this.getTitle() || this._getContent() } setContent(D) { this._sanitizeAndSetContent(D, this.getTitle(), X), this._sanitizeAndSetContent(D, this._getContent(), T) } _getContent() { return this._resolvePossibleFunction(this._config.content) } _getBasicClassPrefix() { return v } static jQueryInterface(D) { return this.each(function () { let q = O.getOrCreateInstance(this, D); if (typeof D == "string") { if (typeof q[D] == "undefined") throw new TypeError(`No method named "${D}"`); q[D]() } }) } } return c(O), O }) }); var br = Ht((yi, Ai) => { (function (t, e) { typeof yi == "object" && typeof Ai != "undefined" ? Ai.exports = e(Ut(), ne(), ie(), Qt()) : typeof define == "function" && define.amd ? define(["./dom/event-handler", "./dom/manipulator", "./dom/selector-engine", "./base-component"], e) : (t = typeof globalThis != "undefined" ? globalThis : t || self, t.ScrollSpy = e(t.EventHandler, t.Manipulator, t.SelectorEngine, t.Base)) })(yi, function (t, e, n, o) { "use strict"; let r = k => k && typeof k == "object" && "default" in k ? k : { default: k }, i = r(t), c = r(e), s = r(n), E = r(o), S = k => k == null ? `${k}` : {}.toString.call(k).match(/\s([a-z]+)/i)[1].toLowerCase(), v = k => { let M = k.getAttribute("data-bs-target"); if (!M || M === "#") { let z = k.getAttribute("href"); if (!z || !z.includes("#") && !z.startsWith(".")) return null; z.includes("#") && !z.startsWith("#") && (z = `#${z.split("#")[1]}`), M = z && z !== "#" ? z.trim() : null } return M }, J = k => { let M = v(k); return M && document.querySelector(M) ? M : null }, tt = k => !k || typeof k != "object" ? !1 : (typeof k.jquery != "undefined" && (k = k[0]), typeof k.nodeType != "undefined"), Y = k => tt(k) ? k.jquery ? k[0] : k : typeof k == "string" && k.length > 0 ? document.querySelector(k) : null, X = (k, M, z) => { Object.keys(z).forEach(mt => { let w = z[mt], L = M[mt], K = L && tt(L) ? "element" : S(L); if (!new RegExp(w).test(K)) throw new TypeError(`${k.toUpperCase()}: Option "${mt}" provided type "${K}" but expected type "${w}".`) }) }, T = () => { let { jQuery: k } = window; return k && !document.body.hasAttribute("data-bs-no-jquery") ? k : null }, O = [], b = k => { document.readyState === "loading" ? (O.length || document.addEventListener("DOMContentLoaded", () => { O.forEach(M => M()) }), O.push(k)) : k() }, D = k => { b(() => { let M = T(); if (M) { let z = k.NAME, mt = M.fn[z]; M.fn[z] = k.jQueryInterface, M.fn[z].Constructor = k, M.fn[z].noConflict = () => (M.fn[z] = mt, k.jQueryInterface) } }) }, q = "scrollspy", l = ".bs.scrollspy", g = ".data-api", y = { offset: 10, method: "auto", target: "" }, W = { offset: "number", method: "string", target: "(string|element)" }, j = `activate${l}`, P = `scroll${l}`, F = `load${l}${g}`, st = "dropdown-item", et = "active", gt = '[data-bs-spy="scroll"]', ct = ".nav, .list-group", nt = ".nav-link", pt = ".nav-item", Et = ".list-group-item", Z = `${nt}, ${Et}, .${st}`, B = ".dropdown", p = ".dropdown-toggle", A = "offset", Q = "position"; class rt extends E.default { constructor(M, z) { super(M); this._scrollElement = this._element.tagName === "BODY" ? window : this._element, this._config = this._getConfig(z), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, i.default.on(this._scrollElement, P, () => this._process()), this.refresh(), this._process() } static get Default() { return y } static get NAME() { return q } refresh() { let M = this._scrollElement === this._scrollElement.window ? A : Q, z = this._config.method === "auto" ? M : this._config.method, mt = z === Q ? this._getScrollTop() : 0; this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), s.default.find(Z, this._config.target).map(L => { let K = J(L), ft = K ? s.default.findOne(K) : null; if (ft) { let St = ft.getBoundingClientRect(); if (St.width || St.height) return [c.default[z](ft).top + mt, K] } return null }).filter(L => L).sort((L, K) => L[0] - K[0]).forEach(L => { this._offsets.push(L[0]), this._targets.push(L[1]) }) } dispose() { i.default.off(this._scrollElement, l), super.dispose() } _getConfig(M) { return M = { ...y, ...c.default.getDataAttributes(this._element), ...typeof M == "object" && M ? M : {} }, M.target = Y(M.target) || document.documentElement, X(q, M, W), M } _getScrollTop() { return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop } _getScrollHeight() { return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight) } _getOffsetHeight() { return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height } _process() { let M = this._getScrollTop() + this._config.offset, z = this._getScrollHeight(), mt = this._config.offset + z - this._getOffsetHeight(); if (this._scrollHeight !== z && this.refresh(), M >= mt) { let w = this._targets[this._targets.length - 1]; this._activeTarget !== w && this._activate(w); return } if (this._activeTarget && M < this._offsets[0] && this._offsets[0] > 0) { this._activeTarget = null, this._clear(); return } for (let w = this._offsets.length; w--;)this._activeTarget !== this._targets[w] && M >= this._offsets[w] && (typeof this._offsets[w + 1] == "undefined" || M < this._offsets[w + 1]) && this._activate(this._targets[w]) } _activate(M) { this._activeTarget = M, this._clear(); let z = Z.split(",").map(w => `${w}[data-bs-target="${M}"],${w}[href="${M}"]`), mt = s.default.findOne(z.join(","), this._config.target); mt.classList.add(et), mt.classList.contains(st) ? s.default.findOne(p, mt.closest(B)).classList.add(et) : s.default.parents(mt, ct).forEach(w => { s.default.prev(w, `${nt}, ${Et}`).forEach(L => L.classList.add(et)), s.default.prev(w, pt).forEach(L => { s.default.children(L, nt).forEach(K => K.classList.add(et)) }) }), i.default.trigger(this._scrollElement, j, { relatedTarget: M }) } _clear() { s.default.find(Z, this._config.target).filter(M => M.classList.contains(et)).forEach(M => M.classList.remove(et)) } static jQueryInterface(M) { return this.each(function () { let z = rt.getOrCreateInstance(this, M); if (typeof M == "string") { if (typeof z[M] == "undefined") throw new TypeError(`No method named "${M}"`); z[M]() } }) } } return i.default.on(window, F, () => { s.default.find(gt).forEach(k => new rt(k)) }), D(rt), rt }) }); var Cr = Ht((Ti, bi) => { (function (t, e) { typeof Ti == "object" && typeof bi != "undefined" ? bi.exports = e(Ut(), ie(), Qt()) : typeof define == "function" && define.amd ? define(["./dom/event-handler", "./dom/selector-engine", "./base-component"], e) : (t = typeof globalThis != "undefined" ? globalThis : t || self, t.Tab = e(t.EventHandler, t.SelectorEngine, t.Base)) })(Ti, function (t, e, n) { "use strict"; let o = B => B && typeof B == "object" && "default" in B ? B : { default: B }, r = o(t), i = o(e), c = o(n), s = B => { let p = B.getAttribute("data-bs-target"); if (!p || p === "#") { let A = B.getAttribute("href"); if (!A || !A.includes("#") && !A.startsWith(".")) return null; A.includes("#") && !A.startsWith("#") && (A = `#${A.split("#")[1]}`), p = A && A !== "#" ? A.trim() : null } return p }, E = B => { let p = s(B); return p ? document.querySelector(p) : null }, S = B => !B || B.nodeType !== Node.ELEMENT_NODE || B.classList.contains("disabled") ? !0 : typeof B.disabled != "undefined" ? B.disabled : B.hasAttribute("disabled") && B.getAttribute("disabled") !== "false", v = B => { B.offsetHeight }, J = () => { let { jQuery: B } = window; return B && !document.body.hasAttribute("data-bs-no-jquery") ? B : null }, tt = [], Y = B => { document.readyState === "loading" ? (tt.length || document.addEventListener("DOMContentLoaded", () => { tt.forEach(p => p()) }), tt.push(B)) : B() }, X = B => { Y(() => { let p = J(); if (p) { let A = B.NAME, Q = p.fn[A]; p.fn[A] = B.jQueryInterface, p.fn[A].Constructor = B, p.fn[A].noConflict = () => (p.fn[A] = Q, B.jQueryInterface) } }) }, T = "tab", b = ".bs.tab", D = ".data-api", q = `hide${b}`, _ = `hidden${b}`, l = `show${b}`, g = `shown${b}`, y = `click${b}${D}`, W = "dropdown-menu", j = "active", P = "fade", F = "show", st = ".dropdown", et = ".nav, .list-group", gt = ".active", ct = ":scope > li > .active", nt = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', pt = ".dropdown-toggle", Et = ":scope > .dropdown-menu .active"; class Z extends c.default { static get NAME() { return T } show() { if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(j)) return; let p, A = E(this._element), Q = this._element.closest(et); if (Q) { let z = Q.nodeName === "UL" || Q.nodeName === "OL" ? ct : gt; p = i.default.find(z, Q), p = p[p.length - 1] } let rt = p ? r.default.trigger(p, q, { relatedTarget: this._element }) : null; if (r.default.trigger(this._element, l, { relatedTarget: p }).defaultPrevented || rt !== null && rt.defaultPrevented) return; this._activate(this._element, Q); let M = () => { r.default.trigger(p, _, { relatedTarget: this._element }), r.default.trigger(this._element, g, { relatedTarget: p }) }; A ? this._activate(A, A.parentNode, M) : M() } _activate(p, A, Q) { let k = (A && (A.nodeName === "UL" || A.nodeName === "OL") ? i.default.find(ct, A) : i.default.children(A, gt))[0], M = Q && k && k.classList.contains(P), z = () => this._transitionComplete(p, k, Q); k && M ? (k.classList.remove(F), this._queueCallback(z, p, !0)) : z() } _transitionComplete(p, A, Q) { if (A) { A.classList.remove(j); let k = i.default.findOne(Et, A.parentNode); k && k.classList.remove(j), A.getAttribute("role") === "tab" && A.setAttribute("aria-selected", !1) } p.classList.add(j), p.getAttribute("role") === "tab" && p.setAttribute("aria-selected", !0), v(p), p.classList.contains(P) && p.classList.add(F); let rt = p.parentNode; if (rt && rt.nodeName === "LI" && (rt = rt.parentNode), rt && rt.classList.contains(W)) { let k = p.closest(st); k && i.default.find(pt, k).forEach(M => M.classList.add(j)), p.setAttribute("aria-expanded", !0) } Q && Q() } static jQueryInterface(p) { return this.each(function () { let A = Z.getOrCreateInstance(this); if (typeof p == "string") { if (typeof A[p] == "undefined") throw new TypeError(`No method named "${p}"`); A[p]() } }) } } return r.default.on(document, y, nt, function (B) { if (["A", "AREA"].includes(this.tagName) && B.preventDefault(), S(this)) return; Z.getOrCreateInstance(this).show() }), X(Z), Z }) }); var Or = Ht((Ci, Oi) => { (function (t, e) { typeof Ci == "object" && typeof Oi != "undefined" ? Oi.exports = e(Ut(), ne(), Qt()) : typeof define == "function" && define.amd ? define(["./dom/event-handler", "./dom/manipulator", "./base-component"], e) : (t = typeof globalThis != "undefined" ? globalThis : t || self, t.Toast = e(t.EventHandler, t.Manipulator, t.Base)) })(Ci, function (t, e, n) { "use strict"; let o = p => p && typeof p == "object" && "default" in p ? p : { default: p }, r = o(t), i = o(e), c = o(n), s = p => p == null ? `${p}` : {}.toString.call(p).match(/\s([a-z]+)/i)[1].toLowerCase(), E = p => { let A = p.getAttribute("data-bs-target"); if (!A || A === "#") { let Q = p.getAttribute("href"); if (!Q || !Q.includes("#") && !Q.startsWith(".")) return null; Q.includes("#") && !Q.startsWith("#") && (Q = `#${Q.split("#")[1]}`), A = Q && Q !== "#" ? Q.trim() : null } return A }, S = p => { let A = E(p); return A ? document.querySelector(A) : null }, v = p => !p || typeof p != "object" ? !1 : (typeof p.jquery != "undefined" && (p = p[0]), typeof p.nodeType != "undefined"), J = (p, A, Q) => { Object.keys(Q).forEach(rt => { let k = Q[rt], M = A[rt], z = M && v(M) ? "element" : s(M); if (!new RegExp(k).test(z)) throw new TypeError(`${p.toUpperCase()}: Option "${rt}" provided type "${z}" but expected type "${k}".`) }) }, tt = p => !p || p.nodeType !== Node.ELEMENT_NODE || p.classList.contains("disabled") ? !0 : typeof p.disabled != "undefined" ? p.disabled : p.hasAttribute("disabled") && p.getAttribute("disabled") !== "false", Y = p => { p.offsetHeight }, X = () => { let { jQuery: p } = window; return p && !document.body.hasAttribute("data-bs-no-jquery") ? p : null }, T = [], O = p => { document.readyState === "loading" ? (T.length || document.addEventListener("DOMContentLoaded", () => { T.forEach(A => A()) }), T.push(p)) : p() }, b = p => { O(() => { let A = X(); if (A) { let Q = p.NAME, rt = A.fn[Q]; A.fn[Q] = p.jQueryInterface, A.fn[Q].Constructor = p, A.fn[Q].noConflict = () => (A.fn[Q] = rt, p.jQueryInterface) } }) }, D = (p, A = "hide") => { let Q = `click.dismiss${p.EVENT_KEY}`, rt = p.NAME; r.default.on(document, Q, `[data-bs-dismiss="${rt}"]`, function (k) { if (["A", "AREA"].includes(this.tagName) && k.preventDefault(), tt(this)) return; let M = S(this) || this.closest(`.${rt}`); p.getOrCreateInstance(M)[A]() }) }, q = "toast", l = ".bs.toast", g = `mouseover${l}`, y = `mouseout${l}`, W = `focusin${l}`, j = `focusout${l}`, P = `hide${l}`, F = `hidden${l}`, st = `show${l}`, et = `shown${l}`, gt = "fade", ct = "hide", nt = "show", pt = "showing", Et = { animation: "boolean", autohide: "boolean", delay: "number" }, Z = { animation: !0, autohide: !0, delay: 5e3 }; class B extends c.default { constructor(A, Q) { super(A); this._config = this._getConfig(Q), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners() } static get DefaultType() { return Et } static get Default() { return Z } static get NAME() { return q } show() { if (r.default.trigger(this._element, st).defaultPrevented) return; this._clearTimeout(), this._config.animation && this._element.classList.add(gt); let Q = () => { this._element.classList.remove(pt), r.default.trigger(this._element, et), this._maybeScheduleHide() }; this._element.classList.remove(ct), Y(this._element), this._element.classList.add(nt), this._element.classList.add(pt), this._queueCallback(Q, this._element, this._config.animation) } hide() { if (!this._element.classList.contains(nt) || r.default.trigger(this._element, P).defaultPrevented) return; let Q = () => { this._element.classList.add(ct), this._element.classList.remove(pt), this._element.classList.remove(nt), r.default.trigger(this._element, F) }; this._element.classList.add(pt), this._queueCallback(Q, this._element, this._config.animation) } dispose() { this._clearTimeout(), this._element.classList.contains(nt) && this._element.classList.remove(nt), super.dispose() } _getConfig(A) { return A = { ...Z, ...i.default.getDataAttributes(this._element), ...typeof A == "object" && A ? A : {} }, J(q, A, this.constructor.DefaultType), A } _maybeScheduleHide() { !this._config.autohide || this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => { this.hide() }, this._config.delay)) } _onInteraction(A, Q) { switch (A.type) { case "mouseover": case "mouseout": this._hasMouseInteraction = Q; break; case "focusin": case "focusout": this._hasKeyboardInteraction = Q; break }if (Q) { this._clearTimeout(); return } let rt = A.relatedTarget; this._element === rt || this._element.contains(rt) || this._maybeScheduleHide() } _setListeners() { r.default.on(this._element, g, A => this._onInteraction(A, !0)), r.default.on(this._element, y, A => this._onInteraction(A, !1)), r.default.on(this._element, W, A => this._onInteraction(A, !0)), r.default.on(this._element, j, A => this._onInteraction(A, !1)) } _clearTimeout() { clearTimeout(this._timeout), this._timeout = null } static jQueryInterface(A) { return this.each(function () { let Q = B.getOrCreateInstance(this, A); if (typeof A == "string") { if (typeof Q[A] == "undefined") throw new TypeError(`No method named "${A}"`); Q[A](this) } }) } } return D(B), b(B), B }) }); var Mc = Kt(Li()), Rc = Kt(Qt()), Pc = Kt(Ii()), $c = Kt(xi()), kc = Kt(Mi()), Vc = Kt(vr()), Hc = Kt(yr()), Bc = Kt(Ar()), Wc = Kt(Tr()), qc = Kt(br()), jc = Kt(Cr()), Fc = Kt(Or()), Yc = Kt(gi()); })();
